{"pages":[],"posts":[{"title":"日志服务之通过消费组消费日志","text":"https://help.aliyun.com/document_detail/28998.html 与使用SDK消费数据相比，使用消费组（ConsumerGroup）消费日志数据的优点在于，用户无需关心日志服务的实现细节和消费者之间的负载均衡、failover等，只需要专注于业务逻辑即可。 启动worker: 12345678910111213141516171819@Testpublic void processor() throws Exception { // 第2个参数是消费者名称, 同一个消费组下面的消费者名称必须不同, 可以使用相同的消费组名称, // 不同的消费者名称在多台机器上启动多个进程, 来均衡消费一个Logstore, 这个时候消费组名称可以使用机器ip来区分. // 第9个参数（maxFetchLogGroupSize）是每次从服务端获取的LogGroup数目, 使用默认值即可, 如有调整请注意取值范围(0,1000]. LogHubConfig config = new LogHubConfig(consumerGroup, consumerName, endpoint, project, logstore, accessKeyId, accessKeySecret, LogHubConfig.ConsumePosition.END_CURSOR); ClientWorker worker = new ClientWorker(new LogHubProcessorFactory(), config); Thread thread = new Thread(worker); // Thread运行之后, Client Worker会自动运行, ClientWorker扩展了Runnable接口. thread.start(); Thread.sleep(60 * 60 * 1000); // 调用worker的shutdown函数, 退出消费实例, 关联的线程也会自动停止. worker.shutdown(); // ClientWorker运行过程中会生成多个异步的Task, shutdown之后最好等待还在执行的Task安全退出, 建议sleep 30s. Thread.sleep(30 * 1000);} 具体处理过程: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic String process(List&lt;LogGroupData&gt; logGroups, ILogHubCheckPointTracker checkPointTracker) { // 这里简单的将获取到的数据打印出来 for (LogGroupData logGroup : logGroups) { FastLogGroup fastLogGroup = logGroup.GetFastLogGroup(); log.info(\"----------------------------- log group -----------------------------\"); log.info(String.format(\"category: %s\", fastLogGroup.getCategory())); log.info(String.format(\"source: %s\", fastLogGroup.getSource())); log.info(String.format(\"topic: %s\", fastLogGroup.getTopic())); log.info(String.format(\"machineUUID: %s\", fastLogGroup.getMachineUUID())); for (int logTagsIndex = 0; logTagsIndex &lt; fastLogGroup.getLogTagsCount(); logTagsIndex++) { FastLogTag fastLogTag = fastLogGroup.getLogTags(logTagsIndex); log.info(String.format(\"tag: %s=%s\", fastLogTag.getKey(), fastLogTag.getValue())); } for (int logsIndex = 0; logsIndex &lt; fastLogGroup.getLogsCount(); logsIndex++) { FastLog fastLog = fastLogGroup.getLogs(logsIndex); log.info(String.format(\"time: %s\", fastLog.getTime())); log.info(String.format(\"contentsCount: %s\", fastLog.getContentsCount())); for (int contentsIndex = 0; contentsIndex &lt; fastLog.getContentsCount(); contentsIndex++) { FastLogContent fastLogContent = fastLog.getContents(contentsIndex); log.info(String.format(\"content: %s=%s\", fastLogContent.getKey(), fastLogContent.getValue())); } } } // 每隔30秒, 写一次check point到服务端, 如果30秒内, worker crash, // 新启动的worker会从上一个check point其消费数据, 有可能有少量的重复数据. long currentTime = System.currentTimeMillis(); if (currentTime - lastCheckTime &gt; 30 * 1000) { try { // 参数true表示立即将check point更新到服务端, // 为false会将check point缓存在本地, 后台默认隔60s会将check point刷新到服务端. checkPointTracker.saveCheckPoint(true); } catch (LogHubCheckPointException e) { log.error(\"check point error\", e); } lastCheckTime = currentTime; } return null;} 源代码:LogHubTests.javaLogHubProcessor.javaLogHubProcessorFactory.javalog4j.properties","link":"/java/aliyun-loghub/"},{"title":"ActiveMQ的简易安装","text":"安装ActiveMQ之前, 我们得先安装Java运行环境. Linux安装包下载地址: apache-activemq-5.14.5-bin.tar.gz 解压后的目录结构如下: 1234567891011121314151617181920212223242526272829303132├── activemq-all-5.14.5.jar├── bin│ ├── activemq│ ├── activemq-diag│ ├── activemq.jar│ ├── env│ ├── linux-x86-32│ │ ├── activemq│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── linux-x86-64│ │ ├── activemq│ │ ├── ActiveMQ.pid│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── macosx│ │ ├── activemq│ │ ├── libwrapper.jnilib│ │ ├── wrapper│ │ └── wrapper.conf│ └── wrapper.jar├── conf├── data├── docs├── examples├── LICENSE├── NOTICE├── README.txt├── webapps└── webapps-demo bin目录下根据不同的操作系统, 提供了不同的启动脚本, 包括: linux-x86-32, linux-x86-64, macosx. 我的服务器是centos7.1系统, 使用的是bin/linux-x86-64/activemq脚本. 12[root@centos apache-activemq-5.14.5]# bin/linux-x86-64/activemqUsage: bin/linux-x86-64/activemq { console | start | stop | restart | status | dump } 启动服务 bin/linux-x86-64/activemq start 查看状态 bin/linux-x86-64/activemq status 管理后台: http://localhost:8161默认账号/密码: admin/admin","link":"/java/activemq-install/"},{"title":"ActiveMQ之发布订阅模型","text":"发布订阅模型(Pub/Sub)使用主题(Topic)作为消息通信载体, 类似于广播模式. 发布者发布一条消息, 该消息通过主题传递给所有的订阅者, 在一条消息广播之后才订阅的用户则是收不到该条消息的. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createTopic(\"mytopic\"); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: queue={} message={}\", \"mytopic\", message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createTopic(\"mytopic\"); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: queue={} message={}\", \"mytopic\", textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); while (true) { Thread.yield(); }} 源代码: TopicTests.java","link":"/java/activemq-topic/"},{"title":"ActiveMQ之点对点模型","text":"点对点模型(Point to Point)使用队列(Queue)作为消息通信载体, 满足生产者与消费者模式. 一条消息只能被一个消费者使用, 未被消费的消息在队列中保留直到被消费或超时. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createQueue(\"myqueue\"); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: queue={} message={}\", \"myqueue\", message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createQueue(\"myqueue\"); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: queue={} message={}\", \"myqueue\", textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); while (true) { Thread.yield(); }} 源代码: QueueTests.java","link":"/java/activemq-queue/"},{"title":"STS临时授权访问OSS","text":"https://help.aliyun.com/document_detail/100624.html OSS可以通过阿里云STS（Security Token Service）进行临时授权访问。 阿里云STS是为云计算用户提供临时访问令牌的Web服务。 通过STS，您可以为第三方应用或子用户（即用户身份由您自己管理的用户）颁发一个自定义时效和权限的访问凭证。 获取临时凭证： 12345678910111213141516171819202122232425262728293031@Testpublic void credentials() throws Exception { String region = \"&lt;region&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String roleArn = \"&lt;role-arn&gt;\"; String roleSessionName = \"test\"; String policy = \"{\\\"Version\\\":\\\"1\\\",\\\"Statement\\\":[{\\\"Effect\\\":\\\"Allow\\\",\\\"Action\\\":[\\\"oss:PutObject\\\"],\\\"Resource\\\":[\\\"acs:oss:*:*:&lt;bucket-name&gt;/*\\\"]}]}\"; IClientProfile clientProfile = DefaultProfile.getProfile(region, accessKeyId, accessKeySecret); IAcsClient acsClient = new DefaultAcsClient(clientProfile); AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest(); assumeRoleRequest.setMethod(MethodType.POST); assumeRoleRequest.setProtocol(ProtocolType.HTTPS); assumeRoleRequest.setRoleArn(roleArn); assumeRoleRequest.setRoleSessionName(roleSessionName); assumeRoleRequest.setPolicy(policy); assumeRoleRequest.setDurationSeconds(60L); AssumeRoleResponse assumeRoleResponse = acsClient.getAcsResponse(assumeRoleRequest); log.info(\"assumeRoleResponse: {}\", assumeRoleResponse); // 临时凭证 if (assumeRoleResponse.getCredentials() != null) { log.info(\"accessKeyId: {}\", assumeRoleResponse.getCredentials().getAccessKeyId()); log.info(\"accessKeySecret: {}\", assumeRoleResponse.getCredentials().getAccessKeySecret()); log.info(\"securityToken: {}\", assumeRoleResponse.getCredentials().getSecurityToken()); log.info(\"expiration: {}\", assumeRoleResponse.getCredentials().getExpiration()); }} 源代码: STSTests.java","link":"/java/aliyun-oss-sts/"},{"title":"快速入门对象存储OSS","text":"https://help.aliyun.com/document_detail/32011.html 介绍如何快速使用OSS Java SDK完成常见操作，如创建存储空间（Bucket）、上传/下载文件（Object）等。 创建存储空间存储空间是OSS全局命名空间，相当于数据的容器，可以存储若干文件。 以下代码用于新建一个存储空间： 123456789101112@Testpublic void createBucket() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); Bucket bucket = ossClient.createBucket(bucketName); log.info(\"bucket: {}\", bucket);} 上传文件以下代码用于上传文件至OSS： 1234567891011121314@Testpublic void putObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; String objectContent = \"{}\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); PutObjectResult putObjectResult = ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(objectContent.getBytes())); log.info(\"putObjectResult: {}\", putObjectResult);} 下载文件以下代码用于获取文件的文本内容： 12345678910111213141516@Testpublic void getObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); OSSObject ossObject = ossClient.getObject(bucketName, objectName); log.info(\"ossObject: {}\", ossObject); String ossObjectContent = IOUtils.readStreamAsString(ossObject.getObjectContent(), \"UTF-8\"); log.info(\"ossObjectContent: {}\", ossObjectContent);} 列举文件以下代码用于列举指定存储空间下的文件。默认列举100个文件。 123456789101112131415@Testpublic void listObjects() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ObjectListing objectListing = ossClient.listObjects(bucketName); log.info(\"objectListing: {}\", objectListing); // 分页查询时使用此marker log.info(\"nextMarker: {}\", objectListing.getNextMarker());} 删除文件以下代码用于删除指定文件： 123456789101112@Testpublic void deleteObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.deleteObject(bucketName, objectName);} 源代码: OSSTests.java","link":"/java/aliyun-oss/"},{"title":"快速解决cmd命令行乱码问题","text":"cmd命令行显示中文乱码, 大多是由cmd窗口的字符编码不匹配导致. 查看当前字符编码: 1chcp 默认情况下, 返回的是936, 对应的字符编码是GBK. 为解决乱码问题, 我们往往会把编码方式改为65001(UTF-8): 1chcp 65001","link":"/windows10/cmd-chcp/"},{"title":"让flux重复执行的案例","text":"案例一: 当数据为空时, 重复执行 最多重复执行3次, 每次间隔1秒 默认值为-1 123456789101112131415161718192021222324252627282930313233343536@Testpublic void repeatWhenEmpty() throws Exception { Flux&lt;Integer&gt; flux = Flux.defer( () -&gt; { log.info(\"return empty flux\"); return Flux.&lt;Integer&gt;empty(); }) .repeatWhen(repeatFactory -&gt; { Integer maxCount = 3; AtomicInteger counter = new AtomicInteger(0); return repeatFactory .takeWhile(size -&gt; { // 重复执行次数加1 Integer count = counter.incrementAndGet(); log.info(\"count={} size={}\", count, size); // 当数据为空时, 重复执行 if (size == 0) { // 最多重复执行3次 if (count &gt;= maxCount) { return false; } return true; } return false; }) // 每次间隔1秒 .delayElements(Duration.ofSeconds(1)); }) .switchIfEmpty(Flux.just(-1)); StepVerifier.create(flux) .expectNext(-1) .verifyComplete();} 源代码: FluxRepeatTests.java","link":"/java/reactor-flux-repeat/"},{"title":"flux发生错误时的处理方式","text":"方式一: 发生错误时, 忽略此数据, 进入下一轮处理 1234567891011121314@Testpublic void onErrorContinue() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 忽略此数据 .onErrorContinue((err, num) -&gt; log.info(\"invalid num: {}\", num)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(5) .verifyComplete();} 方式二: 发生错误时, 忽略此数据, 然后使用[10, 20]继续接下来的操作 1234567891011121314@Testpublic void onErrorResume() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 使用[10, 20]继续接下来的操作 .onErrorResume(e -&gt; Flux.just(10, 20)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(20) .verifyComplete();} 源代码: FluxErrorTests.java","link":"/java/reactor-flux-error/"},{"title":"flux的不同订阅方式","text":"方式一: 异步执行 12345678910@Testpublic void subscribeOn() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(1) // 指定线程池 .subscribeOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNext(1) .verifyComplete();} 方式二: 并行执行 123456789101112@Testpublic void parallel() throws Exception { ParallelFlux&lt;Integer&gt; flux = Flux.range(1, 3) // 并行执行 .parallel() // 指定线程池 .runOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNextCount(3) .verifyComplete();} 方式三: 延迟3秒后执行 12345678910111213@Testpublic void delaySubscription() throws Exception { StepVerifier.withVirtualTime(this::delayedFlux) .thenAwait(Duration.ofSeconds(3)) .expectNext(1) .verifyComplete();}private Flux&lt;Integer&gt; delayedFlux() { return Flux.just(1) // 延迟3秒 .delaySubscription(Duration.ofSeconds(3));} 源代码: FluxSubscribeTests.java","link":"/java/reactor-flux-subscribe/"},{"title":"mono缓存的使用","text":"方式一: 本地缓存 1分钟后过期 1234567891011121314151617@Testpublic void cache() throws Exception { String cacheKey = \"mykey\"; Cache&lt;String, Signal&lt;? extends Integer&gt;&gt; cache = CacheBuilder .newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .build(); Mono&lt;Integer&gt; mono = CacheMono .lookup(cache.asMap(), cacheKey) .onCacheMissResume(Mono.just(1)); StepVerifier.create(mono) .expectNext(1) .verifyComplete();} 源代码: MonoCacheTests.java","link":"/java/reactor-mono-cache/"},{"title":"reactor是如何推送数据的?","text":"方式一: UnicastProcessor 直接推送 线程安全 12345678910111213141516171819202122@Testpublic void unicastProcessor() throws Exception { UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create(); // 用于推送数据 FluxSink&lt;Integer&gt; sink = processor.sink(); // 消息发布者 Flux&lt;Integer&gt; publisher = processor.publish().autoConnect(); // 推送数据[1, 2, 3]后关闭 sink.next(1); sink.next(2); sink.next(3); sink.complete(); StepVerifier.create(publisher) .expectNext(1) .expectNext(2) .expectNext(3) .verifyComplete();} 源代码: ProcessorTests.java","link":"/java/reactor-processor/"}],"tags":[{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"activemq","slug":"activemq","link":"/tags/activemq/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"reactor","slug":"reactor","link":"/tags/reactor/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"windows10","slug":"windows10","link":"/categories/windows10/"}]}