{"pages":[],"posts":[{"title":"ActiveMQ的简易安装","text":"安装ActiveMQ之前, 我们得先安装Java运行环境. Linux安装包下载地址: apache-activemq-5.14.5-bin.tar.gz 解压后的目录结构如下: 1234567891011121314151617181920212223242526272829303132├── activemq-all-5.14.5.jar├── bin│ ├── activemq│ ├── activemq-diag│ ├── activemq.jar│ ├── env│ ├── linux-x86-32│ │ ├── activemq│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── linux-x86-64│ │ ├── activemq│ │ ├── ActiveMQ.pid│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── macosx│ │ ├── activemq│ │ ├── libwrapper.jnilib│ │ ├── wrapper│ │ └── wrapper.conf│ └── wrapper.jar├── conf├── data├── docs├── examples├── LICENSE├── NOTICE├── README.txt├── webapps└── webapps-demo bin目录下根据不同的操作系统, 提供了不同的启动脚本, 包括: linux-x86-32, linux-x86-64, macosx. 我的服务器是centos7.1系统, 使用的是bin/linux-x86-64/activemq脚本. 12[root@centos apache-activemq-5.14.5]# bin/linux-x86-64/activemqUsage: bin/linux-x86-64/activemq { console | start | stop | restart | status | dump } 启动服务 bin/linux-x86-64/activemq start 查看状态 bin/linux-x86-64/activemq status 管理后台: http://localhost:8161默认账号/密码: admin/admin","link":"/java/activemq-install/"},{"title":"ActiveMQ之点对点模型","text":"点对点模型(Point to Point)使用队列(Queue)作为消息通信载体, 满足生产者与消费者模式. 一条消息只能被一个消费者使用, 未被消费的消息在队列中保留直到被消费或超时. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createQueue(\"myqueue\"); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: queue={} message={}\", \"myqueue\", message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createQueue(\"myqueue\"); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: queue={} message={}\", \"myqueue\", textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); while (true) { Thread.yield(); }} 源代码: QueueTests.java","link":"/java/activemq-queue/"},{"title":"ActiveMQ之发布订阅模型","text":"发布订阅模型(Pub/Sub)使用主题(Topic)作为消息通信载体, 类似于广播模式. 发布者发布一条消息, 该消息通过主题传递给所有的订阅者, 在一条消息广播之后才订阅的用户则是收不到该条消息的. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createTopic(\"mytopic\"); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: queue={} message={}\", \"mytopic\", message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createTopic(\"mytopic\"); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: queue={} message={}\", \"mytopic\", textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); while (true) { Thread.yield(); }} 源代码: TopicTests.java","link":"/java/activemq-topic/"},{"title":"MySQL binlog增量订阅与消费组件","text":"https://github.com/alibaba/canal/wiki canal [kə’næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费 工作原理： canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 以下是canal的增量订阅与消费示例: 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void subscribe() throws Exception { String host = \"localhost\"; Integer port = 11111; String destination = \"example\"; String username = \"\"; String password = \"\"; String subscribe = \".*\\\\..*\"; Integer maxBatchSize = 5 * 1024; // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(host, port), destination, username, password); try { connector.connect(); connector.subscribe(subscribe); while (true) { // 获取指定数量的数据 Message message = connector.getWithoutAck(maxBatchSize); long batchId = message.getId(); int batchSize = message.getEntries().size(); if (batchId == -1 || batchSize == 0) { Thread.sleep(3000); continue; } try { CanalPrinter.printSummary(message); CanalPrinter.printEntry(message); // 提交确认 connector.ack(batchId); } catch (Exception e) { // 处理失败, 回滚数据 connector.rollback(batchId); log.error(\"process error\", e); } } } catch (Exception e) { log.error(\"connect error\", e); } finally { connector.disconnect(); }} 源代码:CanalClientTests.javaCanalPrinter.java","link":"/java/alibaba-canal/"},{"title":"日志服务之通过消费组消费日志","text":"https://help.aliyun.com/document_detail/28998.html 与使用SDK消费数据相比，使用消费组（ConsumerGroup）消费日志数据的优点在于，用户无需关心日志服务的实现细节和消费者之间的负载均衡、failover等，只需要专注于业务逻辑即可。 启动worker: 12345678910111213141516171819@Testpublic void processor() throws Exception { // 第2个参数是消费者名称, 同一个消费组下面的消费者名称必须不同, 可以使用相同的消费组名称, // 不同的消费者名称在多台机器上启动多个进程, 来均衡消费一个Logstore, 这个时候消费组名称可以使用机器ip来区分. // 第9个参数（maxFetchLogGroupSize）是每次从服务端获取的LogGroup数目, 使用默认值即可, 如有调整请注意取值范围(0,1000]. LogHubConfig config = new LogHubConfig(consumerGroup, consumerName, endpoint, project, logstore, accessKeyId, accessKeySecret, LogHubConfig.ConsumePosition.END_CURSOR); ClientWorker worker = new ClientWorker(new LogHubProcessorFactory(), config); Thread thread = new Thread(worker); // Thread运行之后, Client Worker会自动运行, ClientWorker扩展了Runnable接口. thread.start(); Thread.sleep(60 * 60 * 1000); // 调用worker的shutdown函数, 退出消费实例, 关联的线程也会自动停止. worker.shutdown(); // ClientWorker运行过程中会生成多个异步的Task, shutdown之后最好等待还在执行的Task安全退出, 建议sleep 30s. Thread.sleep(30 * 1000);} 具体处理过程: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic String process(List&lt;LogGroupData&gt; logGroups, ILogHubCheckPointTracker checkPointTracker) { // 这里简单的将获取到的数据打印出来 for (LogGroupData logGroup : logGroups) { FastLogGroup fastLogGroup = logGroup.GetFastLogGroup(); log.info(\"----------------------------- log group -----------------------------\"); log.info(String.format(\"category: %s\", fastLogGroup.getCategory())); log.info(String.format(\"source: %s\", fastLogGroup.getSource())); log.info(String.format(\"topic: %s\", fastLogGroup.getTopic())); log.info(String.format(\"machineUUID: %s\", fastLogGroup.getMachineUUID())); for (int logTagsIndex = 0; logTagsIndex &lt; fastLogGroup.getLogTagsCount(); logTagsIndex++) { FastLogTag fastLogTag = fastLogGroup.getLogTags(logTagsIndex); log.info(String.format(\"tag: %s=%s\", fastLogTag.getKey(), fastLogTag.getValue())); } for (int logsIndex = 0; logsIndex &lt; fastLogGroup.getLogsCount(); logsIndex++) { FastLog fastLog = fastLogGroup.getLogs(logsIndex); log.info(String.format(\"time: %s\", fastLog.getTime())); log.info(String.format(\"contentsCount: %s\", fastLog.getContentsCount())); for (int contentsIndex = 0; contentsIndex &lt; fastLog.getContentsCount(); contentsIndex++) { FastLogContent fastLogContent = fastLog.getContents(contentsIndex); log.info(String.format(\"content: %s=%s\", fastLogContent.getKey(), fastLogContent.getValue())); } } } // 每隔30秒, 写一次check point到服务端, 如果30秒内, worker crash, // 新启动的worker会从上一个check point其消费数据, 有可能有少量的重复数据. long currentTime = System.currentTimeMillis(); if (currentTime - lastCheckTime &gt; 30 * 1000) { try { // 参数true表示立即将check point更新到服务端, // 为false会将check point缓存在本地, 后台默认隔60s会将check point刷新到服务端. checkPointTracker.saveCheckPoint(true); } catch (LogHubCheckPointException e) { log.error(\"check point error\", e); } lastCheckTime = currentTime; } return null;} 源代码:LogHubTests.javaLogHubProcessor.javaLogHubProcessorFactory.javalog4j.properties","link":"/java/aliyun-loghub/"},{"title":"快速入门对象存储OSS","text":"https://help.aliyun.com/document_detail/32011.html 介绍如何快速使用OSS Java SDK完成常见操作，如创建存储空间（Bucket）、上传/下载文件（Object）等。 创建存储空间存储空间是OSS全局命名空间，相当于数据的容器，可以存储若干文件。 以下代码用于新建一个存储空间： 123456789101112@Testpublic void createBucket() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); Bucket bucket = ossClient.createBucket(bucketName); log.info(\"bucket: {}\", bucket);} 上传文件以下代码用于上传文件至OSS： 1234567891011121314@Testpublic void putObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; String objectContent = \"{}\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); PutObjectResult putObjectResult = ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(objectContent.getBytes())); log.info(\"putObjectResult: {}\", putObjectResult);} 下载文件以下代码用于获取文件的文本内容： 12345678910111213141516@Testpublic void getObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); OSSObject ossObject = ossClient.getObject(bucketName, objectName); log.info(\"ossObject: {}\", ossObject); String ossObjectContent = IOUtils.readStreamAsString(ossObject.getObjectContent(), \"UTF-8\"); log.info(\"ossObjectContent: {}\", ossObjectContent);} 列举文件以下代码用于列举指定存储空间下的文件。默认列举100个文件。 123456789101112131415@Testpublic void listObjects() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ObjectListing objectListing = ossClient.listObjects(bucketName); log.info(\"objectListing: {}\", objectListing); // 分页查询时使用此marker log.info(\"nextMarker: {}\", objectListing.getNextMarker());} 删除文件以下代码用于删除指定文件： 123456789101112@Testpublic void deleteObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.deleteObject(bucketName, objectName);} 源代码: OSSClientTests.java","link":"/java/aliyun-oss/"},{"title":"STS临时授权访问OSS","text":"https://help.aliyun.com/document_detail/100624.html OSS可以通过阿里云STS（Security Token Service）进行临时授权访问。 阿里云STS是为云计算用户提供临时访问令牌的Web服务。 通过STS，您可以为第三方应用或子用户（即用户身份由您自己管理的用户）颁发一个自定义时效和权限的访问凭证。 获取临时凭证： 12345678910111213141516171819202122232425262728293031@Testpublic void getCredentials() throws Exception { String region = \"&lt;region&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String roleArn = \"&lt;role-arn&gt;\"; String roleSessionName = \"test\"; String policy = \"{\\\"Version\\\":\\\"1\\\",\\\"Statement\\\":[{\\\"Effect\\\":\\\"Allow\\\",\\\"Action\\\":[\\\"oss:PutObject\\\"],\\\"Resource\\\":[\\\"acs:oss:*:*:&lt;bucket-name&gt;/*\\\"]}]}\"; IClientProfile clientProfile = DefaultProfile.getProfile(region, accessKeyId, accessKeySecret); IAcsClient acsClient = new DefaultAcsClient(clientProfile); AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest(); assumeRoleRequest.setMethod(MethodType.POST); assumeRoleRequest.setProtocol(ProtocolType.HTTPS); assumeRoleRequest.setRoleArn(roleArn); assumeRoleRequest.setRoleSessionName(roleSessionName); assumeRoleRequest.setPolicy(policy); assumeRoleRequest.setDurationSeconds(60L); AssumeRoleResponse assumeRoleResponse = acsClient.getAcsResponse(assumeRoleRequest); log.info(\"assumeRoleResponse: {}\", assumeRoleResponse); // 临时凭证 if (assumeRoleResponse.getCredentials() != null) { log.info(\"accessKeyId: {}\", assumeRoleResponse.getCredentials().getAccessKeyId()); log.info(\"accessKeySecret: {}\", assumeRoleResponse.getCredentials().getAccessKeySecret()); log.info(\"securityToken: {}\", assumeRoleResponse.getCredentials().getSecurityToken()); log.info(\"expiration: {}\", assumeRoleResponse.getCredentials().getExpiration()); }} 源代码: STSClientTests.java","link":"/java/aliyun-oss-sts/"},{"title":"Apache Commons之JavaBeans工具包beanutils","text":"commons-beanutils是Apache开源组织提供的用于操作JavaBeans的工具包. 使用它, 我们可以很方便的在对象之间复制数据. User对象如下: 12345678public class User { private String id; private String username; private String password; // 省略Getter和Setter方法} 支持属性类型自动转换的功能: 12345678910111213@Testpublic void copyProperties() throws Exception { HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(\"id\", 1); properties.put(\"username\", \"weitangli\"); // User.id是String类型, BeanUtils会自动转换 User user = new User(); BeanUtils.copyProperties(user, properties); BeanUtils.setProperty(user, \"password\", \"123456\"); log.info(\"user: id={} username={} password={}\", user.getId(), user.getUsername(), user.getPassword());} 不支持属性类型自动转换的功能: 12345678910111213@Testpublic void copyProperties() throws Exception { HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(\"id\", \"1\"); properties.put(\"username\", \"weitangli\"); // 严格的数据类型, 否则会抛出异常 User user = new User(); PropertyUtils.copyProperties(user, properties); PropertyUtils.setProperty(user, \"password\", \"123456\"); log.info(\"user: id={} username={} password={}\", user.getId(), user.getUsername(), user.getPassword());} 源代码:User.javaBeanUtilsTests.javaPropertyUtilsTests.java","link":"/java/apache-commons-beanutils/"},{"title":"快速解决cmd命令行乱码问题","text":"cmd命令行显示中文乱码, 大多是由cmd窗口的字符编码不匹配导致. 查看当前字符编码: 1chcp 默认情况下, 返回的是936, 对应的字符编码是GBK. 为解决乱码问题, 我们往往会把编码方式改为65001(UTF-8): 1chcp 65001","link":"/windows10/cmd-chcp/"},{"title":"Apache Maven打包插件Assembly","text":"Apache Maven项目提供的Maven插件Assembly能够将Maven应用的输出及其依赖库整合打包为一个压缩包, 以便于应用的分发使用. 项目结构: 12345678910111213141516171819[root@centos maven-assembly-sample]# tree --dirsfirst.├── src│ ├── main│ │ ├── java│ │ │ └── com│ │ │ └── sample│ │ │ └── Main.java│ │ └── resources│ └── test│ ├── java│ │ └── com│ │ └── sample│ └── resources├── assembly.xml├── pom.xml└── README.md11 directories, 4 files 在pom.xml添加以下内容: 12345678910111213141516171819202122&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.sample.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptors&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; assembly.xml的内容如下: 与依赖包一同打包 排除mysql:mysql-connector-java依赖 123456789101112131415161718192021&lt;assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"&gt; &lt;id&gt;jar-with-dependencies&lt;/id&gt; &lt;formats&gt; &lt;format&gt;jar&lt;/format&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;outputDirectory&gt;/&lt;/outputDirectory&gt; &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt; &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt; &lt;unpack&gt;true&lt;/unpack&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;excludes&gt; &lt;exclude&gt;mysql:mysql-connector-java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; assembly.xml的配置可以参考http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html 编码打包: 1mvn clean package 源代码:Main.javapom.xmlassembly.xml","link":"/java/maven-assembly/"},{"title":"环信即时通讯云IM","text":"开发文档 http://docs-im.easemob.com/start/start 官方示例 https://github.com/easemob/emchat-server-examples 获取凭证12345678910111213@Testpublic void token() throws Exception { String orgName = \"&lt;org-name&gt;\"; String appName = \"&lt;app-name&gt;\"; String grantType = \"&lt;grant-type&gt;\"; String clientId = \"&lt;client-id&gt;\"; String clientSecret = \"&lt;client-secret&gt;\"; Token requestBody = new Token().grantType(grantType).clientId(clientId).clientSecret(clientSecret); String responseBody = new AuthenticationApi().orgNameAppNameTokenPost(orgName, appName, requestBody); log.info(\"responseBody: {}\", responseBody);} 注册用户123456789101112@Testpublic void registerUsers() throws Exception { String orgName = \"&lt;org-name&gt;\"; String appName = \"&lt;app-name&gt;\"; String authorization = \"Bearer &lt;access-token&gt;\"; RegisterUsers requestBody = new RegisterUsers(); requestBody.add(new User().username(\"weitangli\").password(\"123456\")); String responseBody = new UsersApi().orgNameAppNameUsersPost(orgName, appName, requestBody, authorization); log.info(\"responseBody: {}\", responseBody);} 源代码: IMClientTests.java","link":"/java/easemob-im/"},{"title":"flux发生错误时的处理方式","text":"方式一: 发生错误时, 忽略此数据, 进入下一轮处理 1234567891011121314@Testpublic void onErrorContinue() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 忽略此数据 .onErrorContinue((err, num) -&gt; log.info(\"invalid num: {}\", num)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(5) .verifyComplete();} 方式二: 发生错误时, 忽略此数据, 然后使用[10, 20]继续接下来的操作 1234567891011121314@Testpublic void onErrorResume() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 使用[10, 20]继续接下来的操作 .onErrorResume(e -&gt; Flux.just(10, 20)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(20) .verifyComplete();} 源代码: FluxErrorTests.java","link":"/java/reactor-flux-error/"},{"title":"让flux重复执行的案例","text":"案例一: 当数据为空时, 重复执行 最多重复执行3次, 每次间隔1秒 默认值为-1 123456789101112131415161718192021222324252627282930313233343536@Testpublic void repeatWhenEmpty() throws Exception { Flux&lt;Integer&gt; flux = Flux.defer( () -&gt; { log.info(\"return empty flux\"); return Flux.&lt;Integer&gt;empty(); }) .repeatWhen(repeatFactory -&gt; { Integer maxCount = 3; AtomicInteger counter = new AtomicInteger(0); return repeatFactory .takeWhile(size -&gt; { // 重复执行次数加1 Integer count = counter.incrementAndGet(); log.info(\"count={} size={}\", count, size); // 当数据为空时, 重复执行 if (size == 0) { // 最多重复执行3次 if (count &gt;= maxCount) { return false; } return true; } return false; }) // 每次间隔1秒 .delayElements(Duration.ofSeconds(1)); }) .switchIfEmpty(Flux.just(-1)); StepVerifier.create(flux) .expectNext(-1) .verifyComplete();} 源代码: FluxRepeatTests.java","link":"/java/reactor-flux-repeat/"},{"title":"flux的不同订阅方式","text":"方式一: 异步执行 12345678910@Testpublic void subscribeOn() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(1) // 指定线程池 .subscribeOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNext(1) .verifyComplete();} 方式二: 并行执行 123456789101112@Testpublic void parallel() throws Exception { ParallelFlux&lt;Integer&gt; flux = Flux.range(1, 3) // 并行执行 .parallel() // 指定线程池 .runOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNextCount(3) .verifyComplete();} 方式三: 延迟3秒后执行 12345678910111213@Testpublic void delaySubscription() throws Exception { StepVerifier.withVirtualTime(this::delayedFlux) .thenAwait(Duration.ofSeconds(3)) .expectNext(1) .verifyComplete();}private Flux&lt;Integer&gt; delayedFlux() { return Flux.just(1) // 延迟3秒 .delaySubscription(Duration.ofSeconds(3));} 源代码: FluxSubscribeTests.java","link":"/java/reactor-flux-subscribe/"},{"title":"mono缓存的使用","text":"方式一: 本地缓存 1分钟后过期 1234567891011121314151617@Testpublic void cache() throws Exception { String cacheKey = \"mykey\"; Cache&lt;String, Signal&lt;? extends Integer&gt;&gt; cache = CacheBuilder .newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .build(); Mono&lt;Integer&gt; mono = CacheMono .lookup(cache.asMap(), cacheKey) .onCacheMissResume(Mono.just(1)); StepVerifier.create(mono) .expectNext(1) .verifyComplete();} 源代码: MonoCacheTests.java","link":"/java/reactor-mono-cache/"},{"title":"reactor是如何推送数据的?","text":"方式一: UnicastProcessor 直接推送 线程安全 12345678910111213141516171819202122@Testpublic void unicastProcessor() throws Exception { UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create(); // 用于推送数据 FluxSink&lt;Integer&gt; sink = processor.sink(); // 消息发布者 Flux&lt;Integer&gt; publisher = processor.publish().autoConnect(); // 推送数据[1, 2, 3]后关闭 sink.next(1); sink.next(2); sink.next(3); sink.complete(); StepVerifier.create(publisher) .expectNext(1) .expectNext(2) .expectNext(3) .verifyComplete();} 源代码: ProcessorTests.java","link":"/java/reactor-processor/"}],"tags":[{"name":"activemq","slug":"activemq","link":"/tags/activemq/"},{"name":"alibaba","slug":"alibaba","link":"/tags/alibaba/"},{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"apache-commons","slug":"apache-commons","link":"/tags/apache-commons/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"easemob","slug":"easemob","link":"/tags/easemob/"},{"name":"reactor","slug":"reactor","link":"/tags/reactor/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"windows10","slug":"windows10","link":"/categories/windows10/"}]}