{"pages":[],"posts":[{"title":"ActiveMQ之点对点模型","text":"点对点模型(Point to Point)使用队列(Queue)作为消息通信载体, 满足生产者与消费者模式. 一条消息只能被一个消费者使用, 未被消费的消息在队列中保留直到被消费或超时. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createQueue(queueName); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: queue={} message={}\", queueName, message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 123456789101112131415161718192021222324252627282930@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createQueue(queueName); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: queue={} message={}\", queueName, textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); // 防止进程退出, 实际使用不需要这样 Thread.sleep(Integer.MAX_VALUE);} 源代码: QueueTests.java","link":"/activemq-queue/"},{"title":"AES-128加密解密","text":"https://www.it399.com/blog/web/201805211243 密钥对转字符串1234567891011121314@Testpublic void encodeKey() throws Exception { String algorithm = \"AES\"; Integer keySize = 128; Base64.Encoder encoder = Base64.getEncoder(); KeyGenerator generator = KeyGenerator.getInstance(algorithm); generator.init(keySize); SecretKey secretKey = generator.generateKey(); String encodedSecretKey = encoder.encodeToString(secretKey.getEncoded()); log.info(\"encodedSecretKey: {}\", encodedSecretKey);} 字符串转密钥对12345678910@Testpublic void decodeKey() throws Exception { String algorithm = \"AES\"; String encodedSecretKey = \"C00t1uPWrisI2Fwm7MU76g==\"; Base64.Decoder decoder = Base64.getDecoder(); SecretKeySpec secretKey = new SecretKeySpec(decoder.decode(encodedSecretKey), algorithm); log.info(\"secretKey: {}\", secretKey);} 加密 不指定模式和填充, 默认为ECB/PKCS5Padding 123456789101112131415161718192021222324@Testpublic void encrypt() throws Exception { String algorithm = \"AES\"; Integer keySize = 128; String seed = \"abc\"; String content = \"123456\"; Base64.Encoder encoder = Base64.getEncoder(); SecureRandom random = new SecureRandom(); random.setSeed(seed.getBytes(\"UTF-8\")); KeyGenerator generator = KeyGenerator.getInstance(algorithm); generator.init(keySize, random); SecretKey secretKey = generator.generateKey(); Cipher cipher = Cipher.getInstance(algorithm); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] encrypted = cipher.doFinal(content.getBytes(\"UTF-8\")); String cipherText = encoder.encodeToString(encrypted); log.info(\"cipherText: {}\", cipherText);} 解密 不指定模式和填充, 默认为ECB/PKCS5Padding 12345678910111213141516171819202122@Testpublic void decrypt() throws Exception { String algorithm = \"AES\"; Integer keySize = 128; String seed = \"abc\"; String cipherText = \"t988Lq2E/lEH8oTBjGoZOQ==\"; Base64.Decoder decoder = Base64.getDecoder(); SecureRandom random = new SecureRandom(); random.setSeed(seed.getBytes(\"UTF-8\")); KeyGenerator generator = KeyGenerator.getInstance(algorithm); generator.init(keySize, random); SecretKey secretKey = generator.generateKey(); Cipher cipher = Cipher.getInstance(algorithm); cipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] decrypted = cipher.doFinal(decoder.decode(cipherText)); log.info(\"content: {}\", new String(decrypted, \"UTF-8\"));} IV加密 指定模式和填充为CBC/PKCS5Padding 初始化向量Initialization Vector, 必须为16位 12345678910111213141516171819202122232425262728@Testpublic void ivEncrypt() throws Exception { String algorithm = \"AES\"; Integer keySize = 128; String seed = \"abc\"; String iv = \"123456789abcdefg\"; String ivAlgorithm = \"AES/CBC/PKCS5Padding\"; String content = \"123456\"; Base64.Encoder encoder = Base64.getEncoder(); SecureRandom random = new SecureRandom(); random.setSeed(seed.getBytes(\"UTF-8\")); KeyGenerator generator = KeyGenerator.getInstance(algorithm); generator.init(keySize, random); SecretKey secretKey = generator.generateKey(); AlgorithmParameterSpec parameterSpec = new IvParameterSpec(iv.getBytes(\"UTF-8\")); Cipher cipher = Cipher.getInstance(ivAlgorithm); cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec); byte[] encrypted = cipher.doFinal(content.getBytes(\"UTF-8\")); String cipherText = encoder.encodeToString(encrypted); log.info(\"cipherText: {}\", cipherText);} IV解密 指定模式和填充为CBC/PKCS5Padding 初始化向量Initialization Vector, 必须为16位 1234567891011121314151617181920212223242526@Testpublic void ivDecrypt() throws Exception { String algorithm = \"AES\"; Integer keySize = 128; String seed = \"abc\"; String iv = \"123456789abcdefg\"; String ivAlgorithm = \"AES/CBC/PKCS5Padding\"; String cipherText = \"jQBfjxGWOMICDHSo6+FBXQ==\"; Base64.Decoder decoder = Base64.getDecoder(); SecureRandom random = new SecureRandom(); random.setSeed(seed.getBytes(\"UTF-8\")); KeyGenerator generator = KeyGenerator.getInstance(algorithm); generator.init(keySize, random); SecretKey secretKey = generator.generateKey(); AlgorithmParameterSpec parameterSpec = new IvParameterSpec(iv.getBytes(\"UTF-8\")); Cipher cipher = Cipher.getInstance(ivAlgorithm); cipher.init(Cipher.DECRYPT_MODE, secretKey, parameterSpec); byte[] decrypted = cipher.doFinal(decoder.decode(cipherText)); log.info(\"content: {}\", new String(decrypted, \"UTF-8\"));} 源代码: AES128Tests.java","link":"/aes-128/"},{"title":"日志服务之通过消费组消费日志","text":"https://help.aliyun.com/document_detail/28998.html 与使用SDK消费数据相比，使用消费组（ConsumerGroup）消费日志数据的优点在于，用户无需关心日志服务的实现细节和消费者之间的负载均衡、failover等，只需要专注于业务逻辑即可。 启动worker: 12345678910111213141516171819@Testpublic void processor() throws Exception { // 第2个参数是消费者名称, 同一个消费组下面的消费者名称必须不同, 可以使用相同的消费组名称, // 不同的消费者名称在多台机器上启动多个进程, 来均衡消费一个Logstore, 这个时候消费组名称可以使用机器ip来区分. // 第9个参数（maxFetchLogGroupSize）是每次从服务端获取的LogGroup数目, 使用默认值即可, 如有调整请注意取值范围(0,1000]. LogHubConfig config = new LogHubConfig(consumerGroup, consumerName, endpoint, project, logstore, accessKeyId, accessKeySecret, LogHubConfig.ConsumePosition.END_CURSOR); ClientWorker worker = new ClientWorker(new LogHubProcessorFactory(), config); Thread thread = new Thread(worker); // Thread运行之后, Client Worker会自动运行, ClientWorker扩展了Runnable接口. thread.start(); Thread.sleep(60 * 60 * 1000); // 调用worker的shutdown函数, 退出消费实例, 关联的线程也会自动停止. worker.shutdown(); // ClientWorker运行过程中会生成多个异步的Task, shutdown之后最好等待还在执行的Task安全退出, 建议sleep 30s. Thread.sleep(30 * 1000);} 具体处理过程: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic String process(List&lt;LogGroupData&gt; logGroups, ILogHubCheckPointTracker checkPointTracker) { // 这里简单的将获取到的数据打印出来 for (LogGroupData logGroup : logGroups) { FastLogGroup fastLogGroup = logGroup.GetFastLogGroup(); log.info(\"----------------------------- log group -----------------------------\"); log.info(String.format(\"category: %s\", fastLogGroup.getCategory())); log.info(String.format(\"source: %s\", fastLogGroup.getSource())); log.info(String.format(\"topic: %s\", fastLogGroup.getTopic())); log.info(String.format(\"machineUUID: %s\", fastLogGroup.getMachineUUID())); for (int logTagsIndex = 0; logTagsIndex &lt; fastLogGroup.getLogTagsCount(); logTagsIndex++) { FastLogTag fastLogTag = fastLogGroup.getLogTags(logTagsIndex); log.info(String.format(\"tag: %s=%s\", fastLogTag.getKey(), fastLogTag.getValue())); } for (int logsIndex = 0; logsIndex &lt; fastLogGroup.getLogsCount(); logsIndex++) { FastLog fastLog = fastLogGroup.getLogs(logsIndex); log.info(String.format(\"time: %s\", fastLog.getTime())); log.info(String.format(\"contentsCount: %s\", fastLog.getContentsCount())); for (int contentsIndex = 0; contentsIndex &lt; fastLog.getContentsCount(); contentsIndex++) { FastLogContent fastLogContent = fastLog.getContents(contentsIndex); log.info(String.format(\"content: %s=%s\", fastLogContent.getKey(), fastLogContent.getValue())); } } } // 每隔30秒, 写一次check point到服务端, 如果30秒内, worker crash, // 新启动的worker会从上一个check point其消费数据, 有可能有少量的重复数据. long currentTime = System.currentTimeMillis(); if (currentTime - lastCheckTime &gt; 30 * 1000) { try { // 参数true表示立即将check point更新到服务端, // 为false会将check point缓存在本地, 后台默认隔60s会将check point刷新到服务端. checkPointTracker.saveCheckPoint(true); } catch (LogHubCheckPointException e) { log.error(\"check point error\", e); } lastCheckTime = currentTime; } return null;} 源代码:LogHubTests.javaLogHubProcessor.javaLogHubProcessorFactory.javalog4j.properties","link":"/aliyun-loghub/"},{"title":"ActiveMQ之发布订阅模型","text":"发布订阅模型(Pub/Sub)使用主题(Topic)作为消息通信载体, 类似于广播模式. 发布者发布一条消息, 该消息通过主题传递给所有的订阅者, 在一条消息广播之后才订阅的用户则是收不到该条消息的. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createTopic(topicName); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: topic={} message={}\", topicName, message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 123456789101112131415161718192021222324252627282930@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createTopic(topicName); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: topic={} message={}\", topicName, textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); // 防止进程退出, 实际使用不需要这样 Thread.sleep(Integer.MAX_VALUE);} 源代码: TopicTests.java","link":"/activemq-topic/"},{"title":"ActiveMQ的简易安装","text":"安装ActiveMQ之前, 我们得先安装Java运行环境. Linux安装包下载地址: apache-activemq-5.14.5-bin.tar.gz 解压后的目录结构如下: 1234567891011121314151617181920212223242526272829303132├── activemq-all-5.14.5.jar├── bin│ ├── activemq│ ├── activemq-diag│ ├── activemq.jar│ ├── env│ ├── linux-x86-32│ │ ├── activemq│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── linux-x86-64│ │ ├── activemq│ │ ├── ActiveMQ.pid│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── macosx│ │ ├── activemq│ │ ├── libwrapper.jnilib│ │ ├── wrapper│ │ └── wrapper.conf│ └── wrapper.jar├── conf├── data├── docs├── examples├── LICENSE├── NOTICE├── README.txt├── webapps└── webapps-demo bin目录下根据不同的操作系统, 提供了不同的启动脚本, 包括: linux-x86-32, linux-x86-64, macosx. 我的服务器是centos7.1系统, 使用的是bin/linux-x86-64/activemq脚本. 12[root@centos apache-activemq-5.14.5]# bin/linux-x86-64/activemqUsage: bin/linux-x86-64/activemq { console | start | stop | restart | status | dump } 启动服务 bin/linux-x86-64/activemq start 查看状态 bin/linux-x86-64/activemq status 管理后台: http://localhost:8161默认账号/密码: admin/admin","link":"/activemq-install/"},{"title":"MySQL binlog增量订阅与消费组件","text":"https://github.com/alibaba/canal/wiki canal [kə’næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费 工作原理： canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 以下是canal的增量订阅与消费示例: 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void subscribe() throws Exception { String host = \"localhost\"; Integer port = 11111; String destination = \"example\"; String username = \"\"; String password = \"\"; String subscribe = \".*\\\\..*\"; Integer maxBatchSize = 5 * 1024; // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(host, port), destination, username, password); try { connector.connect(); connector.subscribe(subscribe); while (true) { // 获取指定数量的数据 Message message = connector.getWithoutAck(maxBatchSize); long batchId = message.getId(); int batchSize = message.getEntries().size(); if (batchId == -1 || batchSize == 0) { Thread.sleep(3000); continue; } try { CanalPrinter.printSummary(message); CanalPrinter.printEntry(message); // 提交确认 connector.ack(batchId); } catch (Exception e) { // 处理失败, 回滚数据 connector.rollback(batchId); log.error(\"process error\", e); } } } catch (Exception e) { log.error(\"connect error\", e); } finally { connector.disconnect(); }} 源代码:CanalClientTests.javaCanalPrinter.java","link":"/alibaba-canal/"},{"title":"快速入门消息队列ONS","text":"https://help.aliyun.com/document_detail/34411.html 生产者: 1234567891011121314151617181920212223242526@Testpublic void produceMessage() throws Exception { Properties properties = new Properties(); properties.put(PropertyKeyConst.AccessKey, accessKeyId); properties.put(PropertyKeyConst.SecretKey, accessKeySecret); properties.put(PropertyKeyConst.ONSAddr, onsAddr); properties.put(PropertyKeyConst.ProducerId, producerId); // 初始化 Producer producer = ONSFactory.createProducer(properties); // 启动. 在发送消息前, 必须调用start方法来启动Producer, 只需调用一次即可 producer.start(); // 发送消息. 只要不抛异常就是成功 String topic = \"default-mq\"; String tag = \"test\"; String content = \"hello world!\"; Message message = new Message(topic, tag, content.getBytes(Charset.forName(\"UTF-8\"))); SendResult sendResult = producer.send(message); log.info(\"send message: topic={} tag={} content={} messageId={}\", topic, tag, content, sendResult.getMessageId()); // 关闭. 在应用退出前, 可以销毁Producer对象 producer.shutdown();} 消费者: 12345678910111213141516171819202122232425262728@Testpublic void consumeMessage() throws Exception { Properties properties = new Properties(); properties.put(PropertyKeyConst.AccessKey, accessKeyId); properties.put(PropertyKeyConst.SecretKey, accessKeySecret); properties.put(PropertyKeyConst.ONSAddr, onsAddr); properties.put(PropertyKeyConst.ConsumerId, consumerId); // 初始化 Consumer consumer = ONSFactory.createConsumer(properties); // 监听消息 String topic = \"default-mq\"; String subExpression = \"*\"; consumer.subscribe(topic, subExpression, new MessageListener() { @Override public Action consume(Message message, ConsumeContext context) { log.info(\"receive message: topic={} tag={} message={}\", message.getTopic(), message.getTag(), new String(message.getBody())); return Action.CommitMessage; } }); // 启动 consumer.start(); // 防止进程退出, 实际使用不需要这样 Thread.sleep(Integer.MAX_VALUE);} 源代码: DefaultMQTests.java","link":"/aliyun-ons-simple/"},{"title":"STS临时授权访问OSS","text":"https://help.aliyun.com/document_detail/100624.html OSS可以通过阿里云STS（Security Token Service）进行临时授权访问。 阿里云STS是为云计算用户提供临时访问令牌的Web服务。 通过STS，您可以为第三方应用或子用户（即用户身份由您自己管理的用户）颁发一个自定义时效和权限的访问凭证。 获取临时凭证： 12345678910111213141516171819202122232425262728293031@Testpublic void getCredentials() throws Exception { String region = \"&lt;region&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String roleArn = \"&lt;role-arn&gt;\"; String roleSessionName = \"test\"; String policy = \"{\\\"Version\\\":\\\"1\\\",\\\"Statement\\\":[{\\\"Effect\\\":\\\"Allow\\\",\\\"Action\\\":[\\\"oss:PutObject\\\"],\\\"Resource\\\":[\\\"acs:oss:*:*:&lt;bucket-name&gt;/*\\\"]}]}\"; IClientProfile clientProfile = DefaultProfile.getProfile(region, accessKeyId, accessKeySecret); IAcsClient acsClient = new DefaultAcsClient(clientProfile); AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest(); assumeRoleRequest.setMethod(MethodType.POST); assumeRoleRequest.setProtocol(ProtocolType.HTTPS); assumeRoleRequest.setRoleArn(roleArn); assumeRoleRequest.setRoleSessionName(roleSessionName); assumeRoleRequest.setPolicy(policy); assumeRoleRequest.setDurationSeconds(60L); AssumeRoleResponse assumeRoleResponse = acsClient.getAcsResponse(assumeRoleRequest); log.info(\"assumeRoleResponse: {}\", assumeRoleResponse); // 临时凭证 if (assumeRoleResponse.getCredentials() != null) { log.info(\"accessKeyId: {}\", assumeRoleResponse.getCredentials().getAccessKeyId()); log.info(\"accessKeySecret: {}\", assumeRoleResponse.getCredentials().getAccessKeySecret()); log.info(\"securityToken: {}\", assumeRoleResponse.getCredentials().getSecurityToken()); log.info(\"expiration: {}\", assumeRoleResponse.getCredentials().getExpiration()); }} 源代码: STSClientTests.java","link":"/aliyun-oss-sts/"},{"title":"收发事务消息","text":"https://help.aliyun.com/document_detail/29548.html 生产者: 12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void produceMessage() throws Exception { Properties properties = new Properties(); properties.put(PropertyKeyConst.AccessKey, accessKeyId); properties.put(PropertyKeyConst.SecretKey, accessKeySecret); properties.put(PropertyKeyConst.ONSAddr, onsAddr); properties.put(PropertyKeyConst.ProducerId, producerId); // 初始化 TransactionProducer producer = ONSFactory.createTransactionProducer(properties, new LocalTransactionChecker() { @Override public TransactionStatus check(Message message) { log.info(\"check message: topic={} tag={} content={}\", message.getTopic(), message.getTag(), new String(message.getBody())); return TransactionStatus.CommitTransaction; } }); // 启动. 在发送消息前, 必须调用start方法来启动Producer, 只需调用一次即可 producer.start(); // 发送消息. 只要不抛异常就是成功 String topic = \"transaction-mq\"; String tag = \"test\"; String content = \"hello world!\"; Message message = new Message(topic, tag, content.getBytes(Charset.forName(\"UTF-8\"))); // 异常情况下事务消息的回查 LocalTransactionExecuter transactionExecuter = new LocalTransactionExecuter() { @Override public TransactionStatus execute(Message message, Object arg) { log.info(\"execute message: topic={} tag={} content={}\", message.getTopic(), message.getTag(), new String(message.getBody())); return TransactionStatus.CommitTransaction; } }; SendResult sendResult = producer.send(message, transactionExecuter, null); log.info(\"send message: topic={} tag={} content={} messageId={}\", topic, tag, content, sendResult.getMessageId()); // 关闭. 在应用退出前, 可以销毁Producer对象 producer.shutdown(); // 防止进程退出, 实际使用不需要这样 Thread.sleep(Integer.MAX_VALUE);} 消费者: 12345678910111213141516171819202122232425262728@Testpublic void consumeMessage() throws Exception { Properties properties = new Properties(); properties.put(PropertyKeyConst.AccessKey, accessKeyId); properties.put(PropertyKeyConst.SecretKey, accessKeySecret); properties.put(PropertyKeyConst.ONSAddr, onsAddr); properties.put(PropertyKeyConst.ConsumerId, consumerId); // 初始化 Consumer consumer = ONSFactory.createConsumer(properties); // 监听消息 String topic = \"transaction-mq\"; String subExpression = \"*\"; consumer.subscribe(topic, subExpression, new MessageListener() { @Override public Action consume(Message message, ConsumeContext context) { log.info(\"receive message: topic={} tag={} message={}\", message.getTopic(), message.getTag(), new String(message.getBody())); return Action.CommitMessage; } }); // 启动 consumer.start(); // 防止进程退出, 实际使用不需要这样 Thread.sleep(Integer.MAX_VALUE);} 源代码: TransactionMQTests.java","link":"/aliyun-ons-transaction/"},{"title":"快速解决cmd命令行乱码问题","text":"cmd命令行显示中文乱码, 大多是由cmd窗口的字符编码不匹配导致. 查看当前字符编码: 1chcp 默认情况下, 返回的是936, 对应的字符编码是GBK. 为解决乱码问题, 我们往往会把编码方式改为65001(UTF-8): 1chcp 65001","link":"/cmd-chcp/"},{"title":"环信即时通讯云IM","text":"开发文档 https://docs-im.easemob.com/start/start 官方示例 https://github.com/easemob/emchat-server-examples 获取凭证12345678910111213@Testpublic void token() throws Exception { String orgName = \"&lt;org-name&gt;\"; String appName = \"&lt;app-name&gt;\"; String grantType = \"&lt;grant-type&gt;\"; String clientId = \"&lt;client-id&gt;\"; String clientSecret = \"&lt;client-secret&gt;\"; Token requestBody = new Token().grantType(grantType).clientId(clientId).clientSecret(clientSecret); String responseBody = new AuthenticationApi().orgNameAppNameTokenPost(orgName, appName, requestBody); log.info(\"responseBody: {}\", responseBody);} 注册用户123456789101112@Testpublic void registerUsers() throws Exception { String orgName = \"&lt;org-name&gt;\"; String appName = \"&lt;app-name&gt;\"; String authorization = \"Bearer &lt;access-token&gt;\"; RegisterUsers requestBody = new RegisterUsers(); requestBody.add(new User().username(\"weitangli\").password(\"123456\")); String responseBody = new UsersApi().orgNameAppNameUsersPost(orgName, appName, requestBody, authorization); log.info(\"responseBody: {}\", responseBody);} 源代码: IMClientTests.java","link":"/easemob-im/"},{"title":"快速入门对象存储OSS","text":"https://help.aliyun.com/document_detail/32011.html 介绍如何快速使用OSS Java SDK完成常见操作，如创建存储空间（Bucket）、上传/下载文件（Object）等。 创建存储空间存储空间是OSS全局命名空间，相当于数据的容器，可以存储若干文件。 以下代码用于新建一个存储空间： 123456789101112@Testpublic void createBucket() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); Bucket bucket = ossClient.createBucket(bucketName); log.info(\"bucket: {}\", bucket);} 上传文件以下代码用于上传文件至OSS： 1234567891011121314@Testpublic void putObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; String objectContent = \"{}\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); PutObjectResult putObjectResult = ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(objectContent.getBytes())); log.info(\"putObjectResult: {}\", putObjectResult);} 下载文件以下代码用于获取文件的文本内容： 12345678910111213141516@Testpublic void getObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); OSSObject ossObject = ossClient.getObject(bucketName, objectName); log.info(\"ossObject: {}\", ossObject); String ossObjectContent = IOUtils.readStreamAsString(ossObject.getObjectContent(), \"UTF-8\"); log.info(\"ossObjectContent: {}\", ossObjectContent);} 列举文件以下代码用于列举指定存储空间下的文件。默认列举100个文件。 123456789101112131415@Testpublic void listObjects() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ObjectListing objectListing = ossClient.listObjects(bucketName); log.info(\"objectListing: {}\", objectListing); // 分页查询时使用此marker log.info(\"nextMarker: {}\", objectListing.getNextMarker());} 删除文件以下代码用于删除指定文件： 123456789101112@Testpublic void deleteObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.deleteObject(bucketName, objectName);} 源代码: OSSClientTests.java","link":"/aliyun-oss/"},{"title":"Apache Commons之JavaBeans工具包beanutils","text":"commons-beanutils是Apache开源组织提供的用于操作JavaBeans的工具包. 使用它, 我们可以很方便的在对象之间复制数据. User对象如下: 12345678public class User { private String id; private String username; private String password; // 省略Getter和Setter方法} 支持属性类型自动转换的功能: 12345678910111213@Testpublic void copyProperties() throws Exception { HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(\"id\", 1); properties.put(\"username\", \"weitangli\"); // User.id是String类型, BeanUtils会自动转换 User user = new User(); BeanUtils.copyProperties(user, properties); BeanUtils.setProperty(user, \"password\", \"123456\"); log.info(\"user: id={} username={} password={}\", user.getId(), user.getUsername(), user.getPassword());} 不支持属性类型自动转换的功能: 12345678910111213@Testpublic void copyProperties() throws Exception { HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(\"id\", \"1\"); properties.put(\"username\", \"weitangli\"); // 严格的数据类型, 否则会抛出异常 User user = new User(); PropertyUtils.copyProperties(user, properties); PropertyUtils.setProperty(user, \"password\", \"123456\"); log.info(\"user: id={} username={} password={}\", user.getId(), user.getUsername(), user.getPassword());} 源代码:User.javaBeanUtilsTests.javaPropertyUtilsTests.java","link":"/apache-commons-beanutils/"},{"title":"快速安装Flume","text":"https://flume.apache.org 安装Flume之前, 我们得先安装Java运行环境. Linux安装包下载地址: apache-flume-1.6.0-bin.tar.gz 目录结构123456789101112131415161718├── bin│ ├── flume-ng│ ├── flume-ng.cmd│ └── flume-ng.ps1├── conf│ ├── flume-conf.properties.template│ ├── flume-env.ps1.template│ ├── flume-env.sh.template│ └── log4j.properties├── docs├── lib├── tools├── CHANGELOG├── DEVNOTES├── LICENSE├── NOTICE├── README└── RELEASE-NOTES bin目录下提供了启动脚本, 包括了cmd和shell版本. 添加配置添加conf/example-conf.properties, 内容如下: 123456789101112131415example.sources = avroexample.channels = memoryexample.sinks = file_rollexample.sources.avro.type = avroexample.sources.avro.bind = 0.0.0.0example.sources.avro.port = 5555example.sources.avro.channels = memoryexample.sinks.file_roll.type = file_rollexample.sinks.file_roll.sink.directory = /var/flumeexample.sinks.file_roll.channel = memoryexample.channels.memory.type = memoryexample.channels.memory.capacity = 100 启动Flume1bin/flume-ng agent --name example --conf conf --conf-file conf/example-conf.properties -Dflume.root.logger=DEBUG,console","link":"/flume-install/"},{"title":"输出日志到Flume","text":"https://github.com/apache/flume/blob/release-1.6.0/flume-ng-doc/sphinx/FlumeUserGuide.rst 打印日志: 1234@Testpublic void log() { log.info(\"Hello World!\");} log4j配置: 1234567891011log4j.rootLogger=INFO, stdout, flumelog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss.SSS} %5.5p [%25.25t] %60.60l : %m%nlog4j.appender.flume=org.apache.flume.clients.log4jappender.Log4jAppenderlog4j.appender.flume.Hostname=192.168.20.237log4j.appender.flume.Port=5555log4j.appender.flume.UnsafeMode=falselog4j.appender.flume.layout=org.apache.log4j.PatternLayoutlog4j.appender.flume.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss.SSS} %5.5p [%25.25t] %60.60l : %m%n 源代码:FlumeTests.javalog4j.properties","link":"/flume-simple/"},{"title":"manifest配置信息","text":"example.jar目录结构如下: 123├── META-INF│ └── MANIFEST.MF# 省略其它文件 读取MANIFEST.MF信息: 123456789101112131415161718@Testpublic void manifest() throws Exception { String file = \"example.jar\"; try (InputStream input = getClass().getClassLoader().getResourceAsStream(file)) { JarInputStream jar = new JarInputStream(input, true); Manifest manifest = jar.getManifest(); for (Map.Entry&lt;Object, Object&gt; attributes : manifest.getMainAttributes().entrySet()) { log.info(\"main attributes: key={} value={}\", attributes.getKey(), attributes.getValue()); } for (Map.Entry&lt;String, Attributes&gt; entry : manifest.getEntries().entrySet()) { log.info(\"name: {}\", entry.getKey()); for (Map.Entry&lt;Object, Object&gt; attributes : entry.getValue().entrySet()) { log.info(\"attributes: key={} value={}\", attributes.getKey(), attributes.getValue()); } } }} 源代码: ManifestTests.java","link":"/jar-manifest/"},{"title":"JSON解析工具jackson","text":"https://github.com/FasterXML/jackson-databind User对象123456789101112131415161718192021@JsonInclude(JsonInclude.Include.NON_NULL)@JsonIgnoreProperties(ignoreUnknown = true)public class User { @JsonProperty(\"_id\") private Long id; private String username; private String password; @JsonFormat(shape = JsonFormat.Shape.STRING) private Integer age; @JsonFormat(locale = \"zh\", timezone = \"GMT+8\", pattern = \"yyyy-MM-dd\") private Date birth; private Date createTime; // 省略Getter和Setter方法} 对象转字符串12345678910111213141516171819202122232425262728293031323334@Testpublic void writeValue() throws Exception { ObjectMapper mapper = new ObjectMapper(); // 序列化时, 日期格式转为时间戳 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true); // 序列化时, 忽略null值的属性 // 也可以在User类上单独设置@JsonInclude(JsonInclude.Include.NON_NULL) mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); User user = new User(); // 通过@JsonProperty设置别名为\"_id\" user.setId(1L); user.setUsername(\"weitangli\"); // 设置JsonInclude.Include.NON_NULL, 序列化时, 忽略null值的属性 user.setPassword(null); // 通过@JsonFormat设置shape = JsonFormat.Shape.STRING, 序列化时, 类型转化为字符串 user.setAge(27); // 通过@JsonFormat设置字符串格式化SimpleDateFormat的表达式pattern = \"yyyy-MM-dd\" user.setBirth(new Date()); // 在ObjectMapper上设置SerializationFeature.WRITE_DATES_AS_TIMESTAMPS = true, 序列化时会转化为时间戳(毫秒) user.setCreateTime(new Date()); // {\"username\":\"weitangli\",\"age\":\"27\",\"birth\":\"2019-11-28\",\"createTime\":1574907320485,\"_id\":1} String str = mapper.writeValueAsString(user); log.info(\"str: {}\", str);} 字符串转对象1234567891011121314@Testpublic void readValue() throws Exception { ObjectMapper mapper = new ObjectMapper(); // 反序列化时，忽略不存在的属性 // 也可以在User类上单独设置@JsonIgnoreProperties(ignoreUnknown = true) mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); String str = \"{\\\"username\\\":\\\"weitangli\\\",\\\"age\\\":\\\"27\\\",\\\"birth\\\":\\\"2019-11-28\\\",\\\"createTime\\\":1574907320485,\\\"_id\\\":1}\"; User user = mapper.readValue(str, new TypeReference&lt;User&gt;() { }); log.info(\"id={} username={} password={} age={} birth={} createTime={}\", user.getId(), user.getUsername(), user.getPassword(), user.getAge(), user.getBirth(), user.getCreateTime());} 源代码: ObjectMapperTests.java","link":"/jackson/"},{"title":"Excel报表生成类库jxls","text":"http://jxls.sourceforge.net Jxls是一个小型Java库, 可简化Excel报表的生成. Jxls在Excel模板中使用特殊的标记Apache Jexl来定义输出格式和数据布局. Excel模板文件: A1单元格中的批注 jx:area(lastCell=&quot;C3&quot;) 表示模板的区域为A1:C3，在这区域内的标签才会被解析。 A3单元格中的批注 jx:each(var=&quot;user&quot; items=&quot;users&quot; lastCell=&quot;C3&quot;) 用于遍历一个列表 users ，lastCell表示遍历的区域为A3:C3。 12345678910111213141516171819202122@Testpublic void test() throws Exception { String template = \"jxls/jxls.xlsx\"; String target = \"target/jxls.xlsx\"; try (InputStream input = getClass().getClassLoader().getResourceAsStream(template)) { try (OutputStream output = new FileOutputStream(target)) { Context context = new Context(); context.putVar(\"users\", listUser()); JxlsHelper.getInstance().processTemplate(input, output, context); } }}private List&lt;User&gt; listUser() { List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L, \"Elsa\", \"123456\")); list.add(new User(2L, \"Oleg\", \"123456\")); list.add(new User(3L, \"Neil\", \"123456\")); list.add(new User(4L, \"Maria\", \"123456\")); list.add(new User(5L, \"John\", \"123456\")); return list;} 源代码:JxlsTests.javajxls.xlsx","link":"/jxls/"},{"title":"Json Web Token工具","text":"https://github.com/jwtk/jjwt 编码: 12345678910111213141516171819202122@Testpublic void compact() throws Exception { String secretKey = \"123456\"; Claims claims = Jwts.claims(); claims.setId(\"1\"); claims.setIssuer(\"sample\"); claims.setIssuedAt(new Date()); claims.setSubject(\"weitangli\"); claims.setAudience(\"guest\"); // 自定义属性 claims.put(\"uid\", \"1\"); String token = Jwts.builder() .setHeaderParam(Header.TYPE, Header.JWT_TYPE) .setClaims(claims) .signWith(SignatureAlgorithm.HS512, secretKey) .compact(); log.info(\"token: {}\", token);} 解码: 12345678910111213@Testpublic void parse() throws Exception { String secretKey = \"123456\"; String token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJqdGkiOiIxIiwiaXNzIjoic2FtcGxlIiwiaWF0IjoxNTc1MDIyMzIzLCJzdWIiOiJ3ZWl0YW5nbGkiLCJhdWQiOiJndWVzdCIsInVpZCI6IjEifQ.gZIsnPSXpM5NC1aPDlxZ-2nIkXvPgrmo8l351Dz99YaZlBL-SSOgxEP7MwMepFvq0DVkHPQSsbQIt4f8J7vCTw\"; Jws&lt;Claims&gt; jwt = Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(token); log.info(\"jwt: {}\", jwt); Claims claims = jwt.getBody(); log.info(\"claims: {}\", claims);} 源代码: JwtTests.java","link":"/jsonwebtoken/"},{"title":"redis客户端jedis","text":"https://github.com/xetorthio/jedis 单连接123456789@Testpublic void jedis() { // 创建实例 Jedis jedis = new Jedis(\"127.0.0.1\", 6379); // 获取所有keys Set&lt;String&gt; keys = jedis.keys(\"*\"); keys.forEach(key -&gt; log.info(\"key: {}\", key));} 连接池12345678910111213141516171819@Testpublic void jedisPool() { // 连接池配置 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(10);// 对象最大空闲时间 config.setMaxTotal(30);// 最大活动的对象个数 config.setMaxWaitMillis(3 * 1000);// 获取对象时最大等待时间 config.setTestOnBorrow(true);// 打开连接时检查是否可用 // 创建连接池 JedisPool pool = new JedisPool(config, \"127.0.0.1\", 6379); // 获取实例 Jedis jedis = pool.getResource(); // 获取所有keys Set&lt;String&gt; keys = jedis.keys(\"*\"); keys.forEach(key -&gt; log.info(\"key: {}\", key));} 多机连接池123456789101112131415161718192021222324@Testpublic void shardedJedisPool() { // 多机 List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;(); shards.add(new JedisShardInfo(\"127.0.0.1\", 6379)); shards.add(new JedisShardInfo(\"127.0.0.1\", 6389)); // 连接池配置 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(10);// 对象最大空闲时间 config.setMaxTotal(30);// 最大活动的对象个数 config.setMaxWaitMillis(3 * 1000);// 获取对象时最大等待时间 config.setTestOnBorrow(true);// 打开连接时检查是否可用 // 创建连接池 ShardedJedisPool pool = new ShardedJedisPool(config, shards); // 获取实例 ShardedJedis jedis = pool.getResource(); // 获取值 String value = jedis.get(\"name\"); log.info(\"value: {}\", value);} 源代码: JedisTests.java","link":"/jedis/"},{"title":"极光推送","text":"开发文档 https://docs.jiguang.cn/jpush/server/push/server_overview/ 官方示例 https://github.com/jpush/jpush-api-java-client 推送通知123456789101112@Testpublic void token() throws Exception { String masterSecret = \"&lt;master-secret&gt;\"; String appKey = \"&lt;app-id&gt;\"; ClientConfig config = ClientConfig.getInstance(); JPushClient jpushClient = new JPushClient(masterSecret, appKey, null, config); PushPayload pushPayload = PushPayload.alertAll(\"Hello World!\"); PushResult pushResult = jpushClient.sendPush(pushPayload); log.info(\"resultOK: {}\", pushResult.isResultOK());} 源代码: PushClientTests.java","link":"/jiguang-push/"},{"title":"ORM框架jooq","text":"https://www.jooq.org 插入数据1234567891011121314151617@Testpublic void insertInto() throws Exception { try (Connection conn = DriverManager.getConnection(mysqlUrl, mysqlUsername, mysqlPassword)) { DSLContext dsl = DSL.using(conn, SQLDialect.MYSQL); // 要操作的表 TbUser TB_USER = TbUser.TB_USER; // 插入数据 TbUserRecord record = dsl.newRecord(TB_USER); record.setUsername(\"weitangli\"); record.setPassword(\"123456\"); dsl.insertInto(TB_USER).set(record).execute(); } catch (Exception e) { log.error(\"connection error\", e); }} 查询数据1234567891011121314151617@Testpublic void select() throws Exception { try (Connection conn = DriverManager.getConnection(mysqlUrl, mysqlUsername, mysqlPassword)) { DSLContext dsl = DSL.using(conn, SQLDialect.MYSQL); // 要操作的表 TbUser TB_USER = TbUser.TB_USER; // 查询所有数据 List&lt;TbUserRecord&gt; records = dsl.select().from(TB_USER).fetchInto(TB_USER); for (TbUserRecord record : records) { log.info(\"id={} code={} name={}\", record.getId(), record.getUsername(), record.getPassword()); } } catch (Exception e) { log.error(\"connection error\", e); }} 源代码: JooqTests.java","link":"/jooq/"},{"title":"flux发生错误时的处理方式","text":"方式一: 发生错误时, 忽略此数据, 进入下一轮处理 1234567891011121314@Testpublic void onErrorContinue() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 忽略此数据 .onErrorContinue((err, num) -&gt; log.info(\"invalid num: {}\", num)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(5) .verifyComplete();} 方式二: 发生错误时, 忽略此数据, 然后使用[10, 20]继续接下来的操作 1234567891011121314@Testpublic void onErrorResume() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 使用[10, 20]继续接下来的操作 .onErrorResume(e -&gt; Flux.just(10, 20)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(20) .verifyComplete();} 源代码: FluxErrorTests.java","link":"/reactor-flux-error/"},{"title":"网络请求工具okhttp","text":"https://github.com/square/okhttp 发送Get请求12345678910@Testpublic void get() throws Exception { String url = \"https://api.github.com/repos/square/okhttp/contributors\"; Request request = new Request.Builder().url(url).build(); Response response = new OkHttpClient().newCall(request).execute(); ResponseBody responseBody = response.body(); log.info(\"responseBody: {}\", responseBody.string());} 发送Post请求1234567891011121314@Testpublic void post() throws Exception { String url = \"https://api.github.com/repos/square/okhttp/contributors\"; MediaType contentType = MediaType.parse(\"application/json; charset=utf-8\"); String content = \"{}\"; RequestBody requestBody = RequestBody.create(contentType, content); Request request = new Request.Builder().url(url).post(requestBody).build(); Response response = new OkHttpClient().newCall(request).execute(); ResponseBody responseBody = response.body(); log.info(\"responseBody: {}\", responseBody.string());} 源代码: OkHttpTests.java","link":"/okhttp/"},{"title":"Apache Maven打包插件Assembly","text":"Apache Maven项目提供的Maven插件Assembly能够将Maven应用的输出及其依赖库整合打包为一个压缩包, 以便于应用的分发使用. 项目结构: 12345678910111213141516171819[root@centos maven-assembly-sample]# tree --dirsfirst.├── src│ ├── main│ │ ├── java│ │ │ └── com│ │ │ └── sample│ │ │ └── Main.java│ │ └── resources│ └── test│ ├── java│ │ └── com│ │ └── sample│ └── resources├── assembly.xml├── pom.xml└── README.md11 directories, 4 files 在pom.xml添加以下内容: 12345678910111213141516171819202122&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.sample.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptors&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; assembly.xml的内容如下: 与依赖包一同打包 排除mysql:mysql-connector-java依赖 123456789101112131415161718192021&lt;assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"&gt; &lt;id&gt;jar-with-dependencies&lt;/id&gt; &lt;formats&gt; &lt;format&gt;jar&lt;/format&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;outputDirectory&gt;/&lt;/outputDirectory&gt; &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt; &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt; &lt;unpack&gt;true&lt;/unpack&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;excludes&gt; &lt;exclude&gt;mysql:mysql-connector-java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; assembly.xml的配置可以参考http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html 编码打包: 1mvn clean package 源代码:Main.javapom.xmlassembly.xml","link":"/maven-assembly/"},{"title":"让flux重复执行的案例","text":"案例一: 当数据为空时, 重复执行 最多重复执行3次, 每次间隔1秒 默认值为-1 123456789101112131415161718192021222324252627282930313233343536@Testpublic void repeatWhenEmpty() throws Exception { Flux&lt;Integer&gt; flux = Flux.defer( () -&gt; { log.info(\"return empty flux\"); return Flux.&lt;Integer&gt;empty(); }) .repeatWhen(repeatFactory -&gt; { Integer maxCount = 3; AtomicInteger counter = new AtomicInteger(0); return repeatFactory .takeWhile(size -&gt; { // 重复执行次数加1 Integer count = counter.incrementAndGet(); log.info(\"count={} size={}\", count, size); // 当数据为空时, 重复执行 if (size == 0) { // 最多重复执行3次 if (count &gt;= maxCount) { return false; } return true; } return false; }) // 每次间隔1秒 .delayElements(Duration.ofSeconds(1)); }) .switchIfEmpty(Flux.just(-1)); StepVerifier.create(flux) .expectNext(-1) .verifyComplete();} 源代码: FluxRepeatTests.java","link":"/reactor-flux-repeat/"},{"title":"flux的不同订阅方式","text":"方式一: 异步执行 12345678910@Testpublic void subscribeOn() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(1) // 指定线程池 .subscribeOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNext(1) .verifyComplete();} 方式二: 并行执行 123456789101112@Testpublic void parallel() throws Exception { ParallelFlux&lt;Integer&gt; flux = Flux.range(1, 3) // 并行执行 .parallel() // 指定线程池 .runOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNextCount(3) .verifyComplete();} 方式三: 延迟3秒后执行 12345678910111213@Testpublic void delaySubscription() throws Exception { StepVerifier.withVirtualTime(this::delayedFlux) .thenAwait(Duration.ofSeconds(3)) .expectNext(1) .verifyComplete();}private Flux&lt;Integer&gt; delayedFlux() { return Flux.just(1) // 延迟3秒 .delaySubscription(Duration.ofSeconds(3));} 源代码: FluxSubscribeTests.java","link":"/reactor-flux-subscribe/"},{"title":"快速安装Redis","text":"官方网站 https://redis.io 中文网站 http://www.redis.cn Redis是一种高级的Key-Value存储系统, 其中Value支持五种数据类型: string 字符串 list 列表 set 集合 sorted set 有序集合 hash 哈希 Linux安装包下载地址: redis-4.0.14.tar.gz 目录结构1234567891011121314151617├── deps├── src├── tests├── utils├── 00-RELEASENOTES├── BUGS├── CONTRIBUTING├── COPYING├── INSTALL├── Makefile├── MANIFESTO├── README.md├── redis.conf├── runtest├── runtest-cluster├── runtest-sentinel└── sentinel.conf 编译安装1[root@centos redis-4.0.14]# make 启动Server1[root@centos redis-4.0.14]# src/redis-server 打开Client12[root@centos redis-4.0.14]# src/redis-cli127.0.0.1:6379&gt; keys *","link":"/redis-install/"},{"title":"reactor是如何推送数据的?","text":"方式一: UnicastProcessor 直接推送 线程安全 12345678910111213141516171819202122@Testpublic void unicastProcessor() throws Exception { UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create(); // 用于推送数据 FluxSink&lt;Integer&gt; sink = processor.sink(); // 消息发布者 Flux&lt;Integer&gt; publisher = processor.publish().autoConnect(); // 推送数据[1, 2, 3]后关闭 sink.next(1); sink.next(2); sink.next(3); sink.complete(); StepVerifier.create(publisher) .expectNext(1) .expectNext(2) .expectNext(3) .verifyComplete();} 源代码: ProcessorTests.java","link":"/reactor-processor/"},{"title":"mono缓存的使用","text":"方式一: 本地缓存 1分钟后过期 1234567891011121314151617@Testpublic void cache() throws Exception { String cacheKey = \"mykey\"; Cache&lt;String, Signal&lt;? extends Integer&gt;&gt; cache = CacheBuilder .newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .build(); Mono&lt;Integer&gt; mono = CacheMono .lookup(cache.asMap(), cacheKey) .onCacheMissResume(Mono.just(1)); StepVerifier.create(mono) .expectNext(1) .verifyComplete();} 源代码: MonoCacheTests.java","link":"/reactor-mono-cache/"},{"title":"RocketMQ Web管理工具","text":"https://github.com/apache/rocketmq-externals/tree/release-rocketmq-console-1.0.0/rocketmq-console","link":"/rocketmq-console/"},{"title":"RSA-1024加密解密","text":"密钥对转字符串1234567891011121314151617@Testpublic void encodeKey() throws Exception { String algorithm = \"RSA\"; Integer keySize = 1024; Base64.Encoder encoder = Base64.getEncoder(); KeyPairGenerator generator = KeyPairGenerator.getInstance(algorithm); generator.initialize(keySize); KeyPair keyPair = generator.generateKeyPair(); String encodedPublicKey = encoder.encodeToString(keyPair.getPublic().getEncoded()); log.info(\"encodedPublicKey: {}\", encodedPublicKey); String encodedPrivateKey = encoder.encodeToString(keyPair.getPrivate().getEncoded()); log.info(\"encodedPrivateKey: {}\", encodedPrivateKey);} 字符串转密钥对123456789101112131415161718@Testpublic void decodeKey() throws Exception { String algorithm = \"RSA\"; String encodedPublicKey = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCFvVg0HGnNdzE8EseyNd+FEpvwR8QHdhZoRG9DzCqmrnNVfrUAZ45YZ3orq942DDJZHh/0gH75O9hnGaC5tEjIH46FoTounBHXPBqVLTtr8Q2hmGtI29hnwo6D7whnCPcqB8QN9sTC+Gr6MEu4l7BU404FDZPWVld1GeTIZpV7zQIDAQAB\"; String encodedPrivateKey = \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAIW9WDQcac13MTwSx7I134USm/BHxAd2FmhEb0PMKqauc1V+tQBnjlhneiur3jYMMlkeH/SAfvk72GcZoLm0SMgfjoWhOi6cEdc8GpUtO2vxDaGYa0jb2GfCjoPvCGcI9yoHxA32xML4avowS7iXsFTjTgUNk9ZWV3UZ5MhmlXvNAgMBAAECgYEAhI/pnb2MIdzDMIhs6Hf91ilb6A86fyrNiwxKPSliHVVNfLDbOEttDLOEpUT2PRxZy3vQsMmtEd3/4jHE3k2U1VZEkPsFM7HXeVbhbU79ygCj2I2nGc7xLJ5iZtUdfW9Y1ns3ImW3kLajh/eemTQd7csuBnmyOwJpVc8BKao+wAECQQDT2NglWGn97+8LSGH29Lqvd40rqiM2KVtbqE0oIgkpgfK9EJy3W4NKc8yf2bED7Dc1DZOUUnaf5oCfjiICfuTBAkEAoZ0O11ljC4ztzxuUH+lGEf0jHEx3qCmkrfcXiRb4rvHJwC4nvSo7dkWfdY733bNWA+VSzIQA7IZMR41o7mVeDQJBAKVP8JNr5AIR6mLOkAvLO6bTTulE8gdAzJbAxbzMmoO2cPpSbUiz88b0iDgxAu5BtW8D8ibrFsB+ed6IZke2R8ECQAithUF89DuHirFnOrHn9bI7lGoNlRM7gTMyJFphGGNUak/eapXWsbCtFl3ammaWHZVB+AsxP1dz8p6Y8jxyxvUCQCHp9C9VqzqI1IrlK7xnhtoHDHmeE7bL675B2UFzigmXXH6RluVRIPm2cjrJPKcl8E//IaQsJNvYci+1gP8cuDM=\"; Base64.Decoder decoder = Base64.getDecoder(); KeyFactory keyFactory = KeyFactory.getInstance(algorithm); X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(decoder.decode(encodedPublicKey)); PublicKey publicKey = keyFactory.generatePublic(publicKeySpec); log.info(\"publicKey: {}\", publicKey); PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(decoder.decode(encodedPrivateKey)); PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec); log.info(\"privateKey: {}\", privateKey);} 加密123456789101112131415161718192021222324@Testpublic void encrypt() throws Exception { String algorithm = \"RSA\"; Integer keySize = 1024; String seed = \"abc\"; String content = \"123456\"; Base64.Encoder encoder = Base64.getEncoder(); SecureRandom random = new SecureRandom(); random.setSeed(seed.getBytes(\"UTF-8\")); KeyPairGenerator generator = KeyPairGenerator.getInstance(algorithm); generator.initialize(keySize, random); KeyPair keyPair = generator.generateKeyPair(); Cipher cipher = Cipher.getInstance(algorithm); cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic()); byte[] encrypted = cipher.doFinal(content.getBytes(\"UTF-8\")); String cipherText = encoder.encodeToString(encrypted); log.info(\"cipherText: {}\", cipherText);} 解密12345678910111213141516171819202122@Testpublic void decrypt() throws Exception { String algorithm = \"RSA\"; Integer keySize = 1024; String seed = \"abc\"; String cipherText = \"Gvw4zRVwgM9PsnlGwJRf1ZqGPA0+JQ04O1kt6azj7k3gSDaDwiDgKT+i184MV2XJbZ1RyW62e+85gOb0yl+sslxBG1o9I3gRuwv7+fYi0HqZjI+twN9P0X+uKv0ZKfxRMOvmS1gal1gAa+NTORC9+S3pD8z54+oA5W/zAvweYv4=\"; Base64.Decoder decoder = Base64.getDecoder(); SecureRandom random = new SecureRandom(); random.setSeed(seed.getBytes(\"UTF-8\")); KeyPairGenerator generator = KeyPairGenerator.getInstance(algorithm); generator.initialize(keySize, random); KeyPair keyPair = generator.generateKeyPair(); Cipher cipher = Cipher.getInstance(algorithm); cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate()); byte[] decrypted = cipher.doFinal(decoder.decode(cipherText)); log.info(\"content: {}\", new String(decrypted, \"UTF-8\"));} 源代码: RSA1024Tests.java","link":"/rsa-1024/"},{"title":"Redis常见问题","text":"Redis持久化redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。 RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上； AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。 其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。 如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。 缓存穿透、缓存雪崩缓存穿透查询的某一个数据在缓存中一直不存在，造成每一次请求都查询DB的现象。 解决方案： 特殊Value 缓存失效如果缓存在一段时间内失效，DB的压力凸显。 这个没有完美的解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。 缓存失效的情况下，保证有且只有一个线程去更新缓存数据。 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给DB带来很大压力。 解决方案： 随机有效期5-10分钟 二级缓存。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期 同步失败，记录操作日志","link":"/redis-questions/"},{"title":"Java Servlet","text":"生命周期启动时: filter init –&gt; 运行时: servlet init(第一次访问) –&gt; filter doFilter –&gt; servlet service –&gt; 关闭时: servlet destroy –&gt; filter destroy Servlet: 单例 当客户端第一次访问Servlet的时候, 服务器就会创建Servlet实例, 执行init方法 每次请求, 服务器会开一个新的线程访问Servlet中得service方法 当服务器关闭时候, Servlet对象就会被销毁, 执行destory方法 Filter: 单例 当服务器启动的时候, 服务器就会创建Filter实例 当Filter拦截到资源的时候, 就会执行doFilter方法 当服务器关闭的时候, Filter对象就会被销毁, 执行destroy方法 工程结构123456789101112131415161718192021├── src│ ├── main│ │ ├── java│ │ │ └── com│ │ │ └── sample│ │ │ ├── GlobalFilter.java│ │ │ ├── HelloServlet.java│ │ │ └── WebInitializer.java│ │ ├── resources│ │ │ └── META-INF│ │ │ └── services│ │ │ └── javax.servlet.ServletContainerInitializer│ │ └── webapp│ │ └── index.html│ └── test│ ├── java│ │ └── com│ │ └── sample│ └── resources├── pom.xml└── README.md javax.servlet.ServletContainerInitializer文件声明Servlet启动类WebInitializer GlobalFilter全局过滤器 HelloServlet业务处理类 调试运行项目中集成Jetty环境: https://www.eclipse.org/jetty 1mvn jetty:run 访问页面 curl http://localhost:8080/index.html 访问接口 curl http://localhost:8080/hello 编译打包打包成war包 1mvn clean package 源代码:servlet-sample","link":"/servlet/"},{"title":"JVM应用平台vertx","text":"https://vertx.io Vert.x是一个轻量级的高性能JVM应用平台.","link":"/vertx/"},{"title":"爬虫框架webmagic","text":"https://webmagic.io WebMagic是一个简单灵活的Java爬虫框架。基于WebMagic，你可以快速开发出一个高效、易维护的爬虫。 特性： 简单的API，可快速上手 模块化的结构，可轻松扩展 提供多线程和分布式支持 一个爬取Github仓库的示例： 1234567@Testpublic void run() throws Exception { Spider.create(new GithubRepoPageProcessor()) .addUrl(\"https://github.com/code4craft\") .thread(5) .run();} 12345678910111213141516171819202122public class GithubRepoPageProcessor implements PageProcessor { private Site site = Site.me().setRetryTimes(3).setSleepTime(1000).setTimeOut(10000); @Override public void process(Page page) { page.addTargetRequests(page.getHtml().links().regex(\"(https://github\\\\.com/[\\\\w\\\\-]+/[\\\\w\\\\-]+)\").all()); page.addTargetRequests(page.getHtml().links().regex(\"(https://github\\\\.com/[\\\\w\\\\-])\").all()); page.putField(\"author\", page.getUrl().regex(\"https://github\\\\.com/(\\\\w+)/.*\").toString()); page.putField(\"name\", page.getHtml().xpath(\"//h1[@class='entry-title public']/strong/a/text()\").toString()); if (page.getResultItems().get(\"name\") == null) { // skip this page page.setSkip(true); } page.putField(\"readme\", page.getHtml().xpath(\"//div[@id='readme']/tidyText()\")); } @Override public Site getSite() { return site; }} 源代码:SpiderTests.javaGithubRepoPageProcessor.java","link":"/webmagic/"},{"title":"微信个人号API","text":"https://biezhi.github.io/wechat-api/ wechat-api一个基于微信Web协议的Java版本封装，提供了发送消息、接受消息、群操作等功能。 一个例子: 1234@Testpublic void start() { new HelloBot(Config.me().autoLogin(true).showTerminal(true)).start();} 机器人: 12345678910111213141516public class HelloBot extends WeChatBot { private Logger log = LoggerFactory.getLogger(this.getClass()); public HelloBot(Config config) { super(config); } @Bind(msgType = MsgType.TEXT) public void handleText(WeChatMessage message) { if (StringUtils.isNotEmpty(message.getName())) { log.info(\"接收到 [{}] 的消息: {}\", message.getName(), message.getText()); this.sendMsg(message.getFromUserName(), \"自动回复: \" + message.getText()); } }} 源代码:HelloBotTests.javaHelloBot.java","link":"/wechat-api/"},{"title":"快速安装RocketMQ","text":"https://rocketmq.apache.org 安装RocketMQ之前, 我们得先安装Java运行环境. Linux安装包下载地址: rocketmq-all-4.2.0-bin-release.zip 目录结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849├── benchmark├── bin│ ├── cachedog.sh│ ├── cleancache.sh│ ├── cleancache.v1.sh│ ├── mqadmin│ ├── mqadmin.cmd│ ├── mqadmin.xml│ ├── mqbroker│ ├── mqbroker.cmd│ ├── mqbroker.numanode0│ ├── mqbroker.numanode1│ ├── mqbroker.numanode2│ ├── mqbroker.numanode3│ ├── mqbroker.xml│ ├── mqfiltersrv│ ├── mqfiltersrv.cmd│ ├── mqfiltersrv.xml│ ├── mqnamesrv│ ├── mqnamesrv.cmd│ ├── mqnamesrv.xml│ ├── mqshutdown│ ├── mqshutdown.cmd│ ├── os.sh│ ├── play.cmd│ ├── play.sh│ ├── README.md│ ├── runbroker│ ├── runbroker.cmd│ ├── runbroker.sh│ ├── runserver.cmd│ ├── runserver.sh│ ├── setcache.sh│ ├── startfsrv.sh│ ├── tools.cmd│ └── tools.sh├── conf│ ├── 2m-2s-async│ ├── 2m-2s-sync│ ├── 2m-noslave│ ├── broker.conf│ ├── logback_broker.xml│ ├── logback_filtersrv.xml│ ├── logback_namesrv.xml│ └── logback_tools.xml├── lib├── LICENSE├── NOTICE└── README.md bin目录下提供了启动脚本, 包括了cmd和shell版本. 配置修改修改conf/broker.conf, 内容如下: 1234567891011# brokerClusterName = DefaultCluster# brokerName = broker-a# brokerId = 0# deleteWhen = 04# fileReservedTime = 48# brokerRole = ASYNC_MASTER# flushDiskType = ASYNC_FLUSH# 如果不是部署在本地, 得配置具体的IP地址brokerIP1 = localhostbrokerIP2 = localhost 启动NameServer12345nohup bin/mqnamesrv &amp;tail -f ~/logs/rocketmqlogs/namesrv.log# 关闭# bin/mqshutdown namesrv 启动Broker12345nohup bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;tail -f ~/logs/rocketmqlogs/broker.log# 关闭# bin/mqshutdown broker 测试1234567export NAMESRV_ADDR=localhost:9876# 生产者bin/tools.sh org.apache.rocketmq.example.quickstart.Producer# 消费者bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer","link":"/rocketmq-install/"},{"title":"使用RocketMQ收发信息","text":"https://rocketmq.apache.org/docs/simple-example 生产者: 12345678910111213141516171819202122@Testpublic void produceMessage() throws Exception { // 初始化 DefaultMQProducer producer = new DefaultMQProducer(); producer.setNamesrvAddr(namesrvAddr); producer.setProducerGroup(producerGroup); // 启动 producer.start(); // 发送消息 String topic = \"default-mq\"; String tags = \"test\"; String content = \"hello world!\"; Message message = new Message(topic, tags, content.getBytes(Charset.forName(\"UTF-8\"))); SendResult sendResult = producer.send(message); log.info(\"send message: topic={} tags={} content={} status={}\", topic, tags, content, sendResult.getSendStatus().name()); // 关闭 producer.shutdown();} 消费者: 123456789101112131415161718192021222324252627282930@Testpublic void consumeMessage() throws Exception { // 初始化 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(); consumer.setNamesrvAddr(namesrvAddr); consumer.setConsumerGroup(consumerGroup); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); // 订阅消息 String topic = \"default-mq\"; String subExpression = \"*\"; consumer.subscribe(topic, subExpression); // 监听消息 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context) { messages.forEach(message -&gt; { log.info(\"receive message: topic={} tags={} message={}\", message.getTopic(), message.getTags(), new String(message.getBody())); }); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); // 启动 consumer.start(); // 防止进程退出, 实际使用不需要这样 Thread.sleep(Integer.MAX_VALUE);} 源代码: DefaultMQTests.java","link":"/rocketmq-simple/"},{"title":"排序算法","text":"冒泡排序12345678910111213141516171819202122232425262728293031@Testpublic void bubble() { int[] numbers = {3, 2, 1, 5, 4}; log.info(\"numbers: {}\", numbers); sort(numbers); log.info(\"after sort: {}\", numbers);}/** * 冒泡法排序 O(n2) * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 针对所有的元素重复以上的步骤，除了最后一个。 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * * @param numbers 需要排序的整型数组 */public static void sort(int[] numbers) { int temp; // 记录临时中间值 int size = numbers.length; // 数组大小 for (int i = 0; i &lt; size - 1; i++) { for (int j = i + 1; j &lt; size; j++) { if (numbers[i] &lt; numbers[j]) { // 交换两数的位置 temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp; } } }} 插入排序1234567891011121314151617181920212223242526272829@Testpublic void insertion() { int[] numbers = {3, 2, 1, 5, 4}; log.info(\"numbers: {}\", numbers); sort(numbers); log.info(\"after sort: {}\", numbers);}/** * 插入排序 O(n2) * 从第一个元素开始，该元素可以认为已经被排序 * 取出下一个元素，在已经排序的元素序列中从后向前扫描 * 如果该元素（已排序）大于新元素，将该元素移到下一位置 * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 * 将新元素插入到该位置中 * 重复步骤2 * * @param numbers */public static void sort(int[] numbers) { int size = numbers.length, temp, j; for (int i = 1; i &lt; size; i++) { temp = numbers[i]; for (j = i; j &gt; 0 &amp;&amp; temp &lt; numbers[j - 1]; j--) numbers[j] = numbers[j - 1]; numbers[j] = temp; }} 选择排序123456789101112131415161718192021222324252627282930@Testpublic void selection() { int[] numbers = {3, 2, 1, 5, 4}; log.info(\"numbers: {}\", numbers); sort(numbers); log.info(\"after sort: {}\", numbers);}/** * 选择排序 O(n2) * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * 以此类推，直到所有元素均排序完毕。 * * @param numbers */public static void sort(int[] numbers) { int size = numbers.length, temp; for (int i = 0; i &lt; size; i++) { int k = i; for (int j = size - 1; j &gt; i; j--) { if (numbers[j] &lt; numbers[k]) k = j; } temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; }} 源代码:BubbleSortTests.javaInsertionSortTests.javaSelectionSortTests.java","link":"/sorting-algorithms/"}],"tags":[{"name":"activemq","slug":"activemq","link":"/tags/activemq/"},{"name":"aes-128","slug":"aes-128","link":"/tags/aes-128/"},{"name":"aliyun-log","slug":"aliyun-log","link":"/tags/aliyun-log/"},{"name":"alibaba-canal","slug":"alibaba-canal","link":"/tags/alibaba-canal/"},{"name":"aliyun-ons","slug":"aliyun-ons","link":"/tags/aliyun-ons/"},{"name":"aliyun-oss","slug":"aliyun-oss","link":"/tags/aliyun-oss/"},{"name":"chcp","slug":"chcp","link":"/tags/chcp/"},{"name":"easemob-im","slug":"easemob-im","link":"/tags/easemob-im/"},{"name":"apache-commons","slug":"apache-commons","link":"/tags/apache-commons/"},{"name":"flume","slug":"flume","link":"/tags/flume/"},{"name":"jar-manifest","slug":"jar-manifest","link":"/tags/jar-manifest/"},{"name":"jackson","slug":"jackson","link":"/tags/jackson/"},{"name":"jxls","slug":"jxls","link":"/tags/jxls/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"jedis","slug":"jedis","link":"/tags/jedis/"},{"name":"jiguang-push","slug":"jiguang-push","link":"/tags/jiguang-push/"},{"name":"jooq","slug":"jooq","link":"/tags/jooq/"},{"name":"reactor","slug":"reactor","link":"/tags/reactor/"},{"name":"okhttp","slug":"okhttp","link":"/tags/okhttp/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"},{"name":"rsa-1024","slug":"rsa-1024","link":"/tags/rsa-1024/"},{"name":"java-servlet","slug":"java-servlet","link":"/tags/java-servlet/"},{"name":"vertx","slug":"vertx","link":"/tags/vertx/"},{"name":"webmagic","slug":"webmagic","link":"/tags/webmagic/"},{"name":"wechat-api","slug":"wechat-api","link":"/tags/wechat-api/"},{"name":"sorting-algorithms","slug":"sorting-algorithms","link":"/tags/sorting-algorithms/"}],"categories":[{"name":"activemq","slug":"activemq","link":"/categories/activemq/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"aliyun","slug":"aliyun","link":"/categories/aliyun/"},{"name":"alibaba","slug":"alibaba","link":"/categories/alibaba/"},{"name":"cmd","slug":"cmd","link":"/categories/cmd/"},{"name":"flume","slug":"flume","link":"/categories/flume/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"rocketmq","slug":"rocketmq","link":"/categories/rocketmq/"}]}