{"pages":[],"posts":[{"title":"快速解决cmd命令行乱码问题","text":"cmd命令行显示中文乱码, 大多是由cmd窗口的字符编码不匹配导致. 查看当前字符编码: 1chcp 默认情况下, 返回的是936, 对应的字符编码是GBK. 为解决乱码问题, 我们往往会把编码方式改为65001(UTF-8): 1chcp 65001","link":"/windows10/cmd-chcp/"},{"title":"flux发生错误时的处理方式","text":"方式一: 发生错误时, 忽略此数据, 进入下一轮处理 1234567891011121314@Testpublic void onErrorContinue() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 忽略此数据 .onErrorContinue((err, num) -&gt; log.info(\"invalid num: {}\", num)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(5) .verifyComplete();} 方式二: 发生错误时, 忽略此数据, 然后使用[10, 20]继续接下来的操作 1234567891011121314@Testpublic void onErrorResume() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 使用[10, 20]继续接下来的操作 .onErrorResume(e -&gt; Flux.just(10, 20)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(20) .verifyComplete();} 源代码: FluxErrorTests.java","link":"/java/reactor-flux-error/"},{"title":"让flux重复执行的案例","text":"案例一: 当数据为空时, 重复执行 最多重复执行3次, 每次间隔1秒 默认值为-1 123456789101112131415161718192021222324252627282930313233343536@Testpublic void repeatWhenEmpty() throws Exception { Flux&lt;Integer&gt; flux = Flux.defer( () -&gt; { log.info(\"return empty flux\"); return Flux.&lt;Integer&gt;empty(); }) .repeatWhen(repeatFactory -&gt; { Integer maxCount = 3; AtomicInteger counter = new AtomicInteger(0); return repeatFactory .takeWhile(size -&gt; { // 重复执行次数加1 Integer count = counter.incrementAndGet(); log.info(\"count={} size={}\", count, size); // 当数据为空时, 重复执行 if (size == 0) { // 最多重复执行3次 if (count &gt;= maxCount) { return false; } return true; } return false; }) // 每次间隔1秒 .delayElements(Duration.ofSeconds(1)); }) .switchIfEmpty(Flux.just(-1)); StepVerifier.create(flux) .expectNext(-1) .verifyComplete();} 源代码: FluxRepeatTests.java","link":"/java/reactor-flux-repeat/"},{"title":"flux的不同订阅方式","text":"方式一: 异步执行 12345678910@Testpublic void subscribeOn() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(1) // 指定线程池 .subscribeOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNext(1) .verifyComplete();} 方式二: 并行执行 123456789101112@Testpublic void parallel() throws Exception { ParallelFlux&lt;Integer&gt; flux = Flux.range(1, 3) // 并行执行 .parallel() // 指定线程池 .runOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNextCount(3) .verifyComplete();} 方式三: 延迟3秒后执行 12345678910111213@Testpublic void delaySubscription() throws Exception { StepVerifier.withVirtualTime(this::delayedFlux) .thenAwait(Duration.ofSeconds(3)) .expectNext(1) .verifyComplete();}private Flux&lt;Integer&gt; delayedFlux() { return Flux.just(1) // 延迟3秒 .delaySubscription(Duration.ofSeconds(3));} 源代码: FluxSubscribeTests.java","link":"/java/reactor-flux-subscribe/"},{"title":"mono缓存的使用","text":"方式一: 本地缓存 1分钟后过期 1234567891011121314151617@Testpublic void cache() throws Exception { String cacheKey = \"mykey\"; Cache&lt;String, Signal&lt;? extends Integer&gt;&gt; cache = CacheBuilder .newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .build(); Mono&lt;Integer&gt; mono = CacheMono .lookup(cache.asMap(), cacheKey) .onCacheMissResume(Mono.just(1)); StepVerifier.create(mono) .expectNext(1) .verifyComplete();} 源代码: MonoCacheTests.java","link":"/java/reactor-mono-cache/"}],"tags":[{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"reactor","slug":"reactor","link":"/tags/reactor/"}],"categories":[{"name":"windows10","slug":"windows10","link":"/categories/windows10/"},{"name":"java","slug":"java","link":"/categories/java/"}]}