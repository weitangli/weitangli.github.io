{"pages":[],"posts":[{"title":"ActiveMQ的简易安装","text":"安装ActiveMQ之前, 我们得先安装Java运行环境. Linux安装包下载地址: apache-activemq-5.14.5-bin.tar.gz 解压后的目录结构如下: 1234567891011121314151617181920212223242526272829303132├── activemq-all-5.14.5.jar├── bin│ ├── activemq│ ├── activemq-diag│ ├── activemq.jar│ ├── env│ ├── linux-x86-32│ │ ├── activemq│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── linux-x86-64│ │ ├── activemq│ │ ├── ActiveMQ.pid│ │ ├── libwrapper.so│ │ ├── wrapper│ │ └── wrapper.conf│ ├── macosx│ │ ├── activemq│ │ ├── libwrapper.jnilib│ │ ├── wrapper│ │ └── wrapper.conf│ └── wrapper.jar├── conf├── data├── docs├── examples├── LICENSE├── NOTICE├── README.txt├── webapps└── webapps-demo bin目录下根据不同的操作系统, 提供了不同的启动脚本, 包括: linux-x86-32, linux-x86-64, macosx. 我的服务器是centos7.1系统, 使用的是bin/linux-x86-64/activemq脚本. 12[root@centos apache-activemq-5.14.5]# bin/linux-x86-64/activemqUsage: bin/linux-x86-64/activemq { console | start | stop | restart | status | dump } 启动服务 bin/linux-x86-64/activemq start 查看状态 bin/linux-x86-64/activemq status 管理后台: http://localhost:8161默认账号/密码: admin/admin","link":"/java/activemq-install/"},{"title":"ActiveMQ之点对点模型","text":"点对点模型(Point to Point)使用队列(Queue)作为消息通信载体, 满足生产者与消费者模式. 一条消息只能被一个消费者使用, 未被消费的消息在队列中保留直到被消费或超时. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createQueue(queueName); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: queue={} message={}\", queueName, message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createQueue(queueName); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: queue={} message={}\", queueName, textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); while (true) { Thread.yield(); }} 源代码: QueueTests.java","link":"/java/activemq-queue/"},{"title":"ActiveMQ之发布订阅模型","text":"发布订阅模型(Pub/Sub)使用主题(Topic)作为消息通信载体, 类似于广播模式. 发布者发布一条消息, 该消息通过主题传递给所有的订阅者, 在一条消息广播之后才订阅的用户则是收不到该条消息的. 生产者: 12345678910111213141516171819202122232425@Testpublic void produceMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建生产者 Destination destination = session.createTopic(topicName); MessageProducer producer = session.createProducer(destination); // 发送消息 TextMessage message = session.createTextMessage(\"hello world!\"); producer.send(message); log.info(\"send message: topic={} message={}\", topicName, message.getText()); // 关闭会话 session.close(); // 关闭连接 connection.close();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 连接服务端 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消费者 Destination destination = session.createTopic(topicName); MessageConsumer consumer = session.createConsumer(destination); MessageListener listener = new MessageListener() { @Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; log.info(\"receive message: topic={} message={}\", topicName, textMessage.getText()); } catch (JMSException e) { log.error(\"consume error\", e); } } }; consumer.setMessageListener(listener); while (true) { Thread.yield(); }} 源代码: TopicTests.java","link":"/java/activemq-topic/"},{"title":"MySQL binlog增量订阅与消费组件","text":"https://github.com/alibaba/canal/wiki canal [kə’næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费 工作原理： canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 以下是canal的增量订阅与消费示例: 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void subscribe() throws Exception { String host = \"localhost\"; Integer port = 11111; String destination = \"example\"; String username = \"\"; String password = \"\"; String subscribe = \".*\\\\..*\"; Integer maxBatchSize = 5 * 1024; // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(host, port), destination, username, password); try { connector.connect(); connector.subscribe(subscribe); while (true) { // 获取指定数量的数据 Message message = connector.getWithoutAck(maxBatchSize); long batchId = message.getId(); int batchSize = message.getEntries().size(); if (batchId == -1 || batchSize == 0) { Thread.sleep(3000); continue; } try { CanalPrinter.printSummary(message); CanalPrinter.printEntry(message); // 提交确认 connector.ack(batchId); } catch (Exception e) { // 处理失败, 回滚数据 connector.rollback(batchId); log.error(\"process error\", e); } } } catch (Exception e) { log.error(\"connect error\", e); } finally { connector.disconnect(); }} 源代码:CanalClientTests.javaCanalPrinter.java","link":"/java/alibaba-canal/"},{"title":"日志服务之通过消费组消费日志","text":"https://help.aliyun.com/document_detail/28998.html 与使用SDK消费数据相比，使用消费组（ConsumerGroup）消费日志数据的优点在于，用户无需关心日志服务的实现细节和消费者之间的负载均衡、failover等，只需要专注于业务逻辑即可。 启动worker: 12345678910111213141516171819@Testpublic void processor() throws Exception { // 第2个参数是消费者名称, 同一个消费组下面的消费者名称必须不同, 可以使用相同的消费组名称, // 不同的消费者名称在多台机器上启动多个进程, 来均衡消费一个Logstore, 这个时候消费组名称可以使用机器ip来区分. // 第9个参数（maxFetchLogGroupSize）是每次从服务端获取的LogGroup数目, 使用默认值即可, 如有调整请注意取值范围(0,1000]. LogHubConfig config = new LogHubConfig(consumerGroup, consumerName, endpoint, project, logstore, accessKeyId, accessKeySecret, LogHubConfig.ConsumePosition.END_CURSOR); ClientWorker worker = new ClientWorker(new LogHubProcessorFactory(), config); Thread thread = new Thread(worker); // Thread运行之后, Client Worker会自动运行, ClientWorker扩展了Runnable接口. thread.start(); Thread.sleep(60 * 60 * 1000); // 调用worker的shutdown函数, 退出消费实例, 关联的线程也会自动停止. worker.shutdown(); // ClientWorker运行过程中会生成多个异步的Task, shutdown之后最好等待还在执行的Task安全退出, 建议sleep 30s. Thread.sleep(30 * 1000);} 具体处理过程: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic String process(List&lt;LogGroupData&gt; logGroups, ILogHubCheckPointTracker checkPointTracker) { // 这里简单的将获取到的数据打印出来 for (LogGroupData logGroup : logGroups) { FastLogGroup fastLogGroup = logGroup.GetFastLogGroup(); log.info(\"----------------------------- log group -----------------------------\"); log.info(String.format(\"category: %s\", fastLogGroup.getCategory())); log.info(String.format(\"source: %s\", fastLogGroup.getSource())); log.info(String.format(\"topic: %s\", fastLogGroup.getTopic())); log.info(String.format(\"machineUUID: %s\", fastLogGroup.getMachineUUID())); for (int logTagsIndex = 0; logTagsIndex &lt; fastLogGroup.getLogTagsCount(); logTagsIndex++) { FastLogTag fastLogTag = fastLogGroup.getLogTags(logTagsIndex); log.info(String.format(\"tag: %s=%s\", fastLogTag.getKey(), fastLogTag.getValue())); } for (int logsIndex = 0; logsIndex &lt; fastLogGroup.getLogsCount(); logsIndex++) { FastLog fastLog = fastLogGroup.getLogs(logsIndex); log.info(String.format(\"time: %s\", fastLog.getTime())); log.info(String.format(\"contentsCount: %s\", fastLog.getContentsCount())); for (int contentsIndex = 0; contentsIndex &lt; fastLog.getContentsCount(); contentsIndex++) { FastLogContent fastLogContent = fastLog.getContents(contentsIndex); log.info(String.format(\"content: %s=%s\", fastLogContent.getKey(), fastLogContent.getValue())); } } } // 每隔30秒, 写一次check point到服务端, 如果30秒内, worker crash, // 新启动的worker会从上一个check point其消费数据, 有可能有少量的重复数据. long currentTime = System.currentTimeMillis(); if (currentTime - lastCheckTime &gt; 30 * 1000) { try { // 参数true表示立即将check point更新到服务端, // 为false会将check point缓存在本地, 后台默认隔60s会将check point刷新到服务端. checkPointTracker.saveCheckPoint(true); } catch (LogHubCheckPointException e) { log.error(\"check point error\", e); } lastCheckTime = currentTime; } return null;} 源代码:LogHubTests.javaLogHubProcessor.javaLogHubProcessorFactory.javalog4j.properties","link":"/java/aliyun-loghub/"},{"title":"STS临时授权访问OSS","text":"https://help.aliyun.com/document_detail/100624.html OSS可以通过阿里云STS（Security Token Service）进行临时授权访问。 阿里云STS是为云计算用户提供临时访问令牌的Web服务。 通过STS，您可以为第三方应用或子用户（即用户身份由您自己管理的用户）颁发一个自定义时效和权限的访问凭证。 获取临时凭证： 12345678910111213141516171819202122232425262728293031@Testpublic void getCredentials() throws Exception { String region = \"&lt;region&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String roleArn = \"&lt;role-arn&gt;\"; String roleSessionName = \"test\"; String policy = \"{\\\"Version\\\":\\\"1\\\",\\\"Statement\\\":[{\\\"Effect\\\":\\\"Allow\\\",\\\"Action\\\":[\\\"oss:PutObject\\\"],\\\"Resource\\\":[\\\"acs:oss:*:*:&lt;bucket-name&gt;/*\\\"]}]}\"; IClientProfile clientProfile = DefaultProfile.getProfile(region, accessKeyId, accessKeySecret); IAcsClient acsClient = new DefaultAcsClient(clientProfile); AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest(); assumeRoleRequest.setMethod(MethodType.POST); assumeRoleRequest.setProtocol(ProtocolType.HTTPS); assumeRoleRequest.setRoleArn(roleArn); assumeRoleRequest.setRoleSessionName(roleSessionName); assumeRoleRequest.setPolicy(policy); assumeRoleRequest.setDurationSeconds(60L); AssumeRoleResponse assumeRoleResponse = acsClient.getAcsResponse(assumeRoleRequest); log.info(\"assumeRoleResponse: {}\", assumeRoleResponse); // 临时凭证 if (assumeRoleResponse.getCredentials() != null) { log.info(\"accessKeyId: {}\", assumeRoleResponse.getCredentials().getAccessKeyId()); log.info(\"accessKeySecret: {}\", assumeRoleResponse.getCredentials().getAccessKeySecret()); log.info(\"securityToken: {}\", assumeRoleResponse.getCredentials().getSecurityToken()); log.info(\"expiration: {}\", assumeRoleResponse.getCredentials().getExpiration()); }} 源代码: STSClientTests.java","link":"/java/aliyun-oss-sts/"},{"title":"快速入门对象存储OSS","text":"https://help.aliyun.com/document_detail/32011.html 介绍如何快速使用OSS Java SDK完成常见操作，如创建存储空间（Bucket）、上传/下载文件（Object）等。 创建存储空间存储空间是OSS全局命名空间，相当于数据的容器，可以存储若干文件。 以下代码用于新建一个存储空间： 123456789101112@Testpublic void createBucket() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); Bucket bucket = ossClient.createBucket(bucketName); log.info(\"bucket: {}\", bucket);} 上传文件以下代码用于上传文件至OSS： 1234567891011121314@Testpublic void putObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; String objectContent = \"{}\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); PutObjectResult putObjectResult = ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(objectContent.getBytes())); log.info(\"putObjectResult: {}\", putObjectResult);} 下载文件以下代码用于获取文件的文本内容： 12345678910111213141516@Testpublic void getObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); OSSObject ossObject = ossClient.getObject(bucketName, objectName); log.info(\"ossObject: {}\", ossObject); String ossObjectContent = IOUtils.readStreamAsString(ossObject.getObjectContent(), \"UTF-8\"); log.info(\"ossObjectContent: {}\", ossObjectContent);} 列举文件以下代码用于列举指定存储空间下的文件。默认列举100个文件。 123456789101112131415@Testpublic void listObjects() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ObjectListing objectListing = ossClient.listObjects(bucketName); log.info(\"objectListing: {}\", objectListing); // 分页查询时使用此marker log.info(\"nextMarker: {}\", objectListing.getNextMarker());} 删除文件以下代码用于删除指定文件： 123456789101112@Testpublic void deleteObject() throws Exception { String endpoint = \"&lt;endpoint&gt;\"; String accessKeyId = \"&lt;access-key-id&gt;\"; String accessKeySecret = \"&lt;access-key-secret&gt;\"; String bucketName = \"&lt;bucket-name&gt;\"; String objectName = \"&lt;object-name&gt;\"; OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.deleteObject(bucketName, objectName);} 源代码: OSSClientTests.java","link":"/java/aliyun-oss/"},{"title":"Apache Commons之JavaBeans工具包beanutils","text":"commons-beanutils是Apache开源组织提供的用于操作JavaBeans的工具包. 使用它, 我们可以很方便的在对象之间复制数据. User对象如下: 12345678public class User { private String id; private String username; private String password; // 省略Getter和Setter方法} 支持属性类型自动转换的功能: 12345678910111213@Testpublic void copyProperties() throws Exception { HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(\"id\", 1); properties.put(\"username\", \"weitangli\"); // User.id是String类型, BeanUtils会自动转换 User user = new User(); BeanUtils.copyProperties(user, properties); BeanUtils.setProperty(user, \"password\", \"123456\"); log.info(\"user: id={} username={} password={}\", user.getId(), user.getUsername(), user.getPassword());} 不支持属性类型自动转换的功能: 12345678910111213@Testpublic void copyProperties() throws Exception { HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(\"id\", \"1\"); properties.put(\"username\", \"weitangli\"); // 严格的数据类型, 否则会抛出异常 User user = new User(); PropertyUtils.copyProperties(user, properties); PropertyUtils.setProperty(user, \"password\", \"123456\"); log.info(\"user: id={} username={} password={}\", user.getId(), user.getUsername(), user.getPassword());} 源代码:User.javaBeanUtilsTests.javaPropertyUtilsTests.java","link":"/java/apache-commons-beanutils/"},{"title":"快速解决cmd命令行乱码问题","text":"cmd命令行显示中文乱码, 大多是由cmd窗口的字符编码不匹配导致. 查看当前字符编码: 1chcp 默认情况下, 返回的是936, 对应的字符编码是GBK. 为解决乱码问题, 我们往往会把编码方式改为65001(UTF-8): 1chcp 65001","link":"/windows10/cmd-chcp/"},{"title":"JSON解析工具jackson","text":"https://github.com/FasterXML/jackson-databind User对象123456789101112131415161718192021@JsonInclude(JsonInclude.Include.NON_NULL)@JsonIgnoreProperties(ignoreUnknown = true)public class User { @JsonProperty(\"_id\") private Long id; private String username; private String password; @JsonFormat(shape = JsonFormat.Shape.STRING) private Integer age; @JsonFormat(locale = \"zh\", timezone = \"GMT+8\", pattern = \"yyyy-MM-dd\") private Date birth; private Date createTime; // 省略Getter和Setter方法} 对象转字符串12345678910111213141516171819202122232425262728293031323334@Testpublic void writeValue() throws Exception { ObjectMapper mapper = new ObjectMapper(); // 序列化时, 日期格式转为时间戳 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true); // 序列化时, 忽略null值的属性 // 也可以在User类上单独设置@JsonInclude(JsonInclude.Include.NON_NULL) mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); User user = new User(); // 通过@JsonProperty设置别名为\"_id\" user.setId(1L); user.setUsername(\"weitangli\"); // 设置JsonInclude.Include.NON_NULL, 序列化时, 忽略null值的属性 user.setPassword(null); // 通过@JsonFormat设置shape = JsonFormat.Shape.STRING, 序列化时, 类型转化为字符串 user.setAge(27); // 通过@JsonFormat设置字符串格式化SimpleDateFormat的表达式pattern = \"yyyy-MM-dd\" user.setBirth(new Date()); // 在ObjectMapper上设置SerializationFeature.WRITE_DATES_AS_TIMESTAMPS = true, 序列化时会转化为时间戳(毫秒) user.setCreateTime(new Date()); // {\"username\":\"weitangli\",\"age\":\"27\",\"birth\":\"2019-11-28\",\"createTime\":1574907320485,\"_id\":1} String str = mapper.writeValueAsString(user); log.info(\"str: {}\", str);} 字符串转对象1234567891011121314@Testpublic void readValue() throws Exception { ObjectMapper mapper = new ObjectMapper(); // 反序列化时，忽略不存在的属性 // 也可以在User类上单独设置@JsonIgnoreProperties(ignoreUnknown = true) mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); String str = \"{\\\"username\\\":\\\"weitangli\\\",\\\"age\\\":\\\"27\\\",\\\"birth\\\":\\\"2019-11-28\\\",\\\"createTime\\\":1574907320485,\\\"_id\\\":1}\"; User user = mapper.readValue(str, new TypeReference&lt;User&gt;() { }); log.info(\"id={} username={} password={} age={} birth={} createTime={}\", user.getId(), user.getUsername(), user.getPassword(), user.getAge(), user.getBirth(), user.getCreateTime());} 源代码: ObjectMapperTests.java","link":"/java/jackson/"},{"title":"环信即时通讯云IM","text":"开发文档 https://docs-im.easemob.com/start/start 官方示例 https://github.com/easemob/emchat-server-examples 获取凭证12345678910111213@Testpublic void token() throws Exception { String orgName = \"&lt;org-name&gt;\"; String appName = \"&lt;app-name&gt;\"; String grantType = \"&lt;grant-type&gt;\"; String clientId = \"&lt;client-id&gt;\"; String clientSecret = \"&lt;client-secret&gt;\"; Token requestBody = new Token().grantType(grantType).clientId(clientId).clientSecret(clientSecret); String responseBody = new AuthenticationApi().orgNameAppNameTokenPost(orgName, appName, requestBody); log.info(\"responseBody: {}\", responseBody);} 注册用户123456789101112@Testpublic void registerUsers() throws Exception { String orgName = \"&lt;org-name&gt;\"; String appName = \"&lt;app-name&gt;\"; String authorization = \"Bearer &lt;access-token&gt;\"; RegisterUsers requestBody = new RegisterUsers(); requestBody.add(new User().username(\"weitangli\").password(\"123456\")); String responseBody = new UsersApi().orgNameAppNameUsersPost(orgName, appName, requestBody, authorization); log.info(\"responseBody: {}\", responseBody);} 源代码: IMClientTests.java","link":"/java/easemob-im/"},{"title":"ORM框架jooq","text":"https://www.jooq.org 插入数据1234567891011121314151617@Testpublic void insertInto() throws Exception { try (Connection conn = DriverManager.getConnection(mysqlUrl, mysqlUsername, mysqlPassword)) { DSLContext dsl = DSL.using(conn, SQLDialect.MYSQL); // 要操作的表 TbUser TB_USER = TbUser.TB_USER; // 插入数据 TbUserRecord record = dsl.newRecord(TB_USER); record.setUsername(\"weitangli\"); record.setPassword(\"123456\"); dsl.insertInto(TB_USER).set(record).execute(); } catch (Exception e) { log.error(\"connection error\", e); }} 查询数据1234567891011121314151617@Testpublic void select() throws Exception { try (Connection conn = DriverManager.getConnection(mysqlUrl, mysqlUsername, mysqlPassword)) { DSLContext dsl = DSL.using(conn, SQLDialect.MYSQL); // 要操作的表 TbUser TB_USER = TbUser.TB_USER; // 查询所有数据 List&lt;TbUserRecord&gt; records = dsl.select().from(TB_USER).fetchInto(TB_USER); for (TbUserRecord record : records) { log.info(\"id={} code={} name={}\", record.getId(), record.getUsername(), record.getPassword()); } } catch (Exception e) { log.error(\"connection error\", e); }} 源代码: JooqTests.java","link":"/java/jooq/"},{"title":"极光推送","text":"开发文档 https://docs.jiguang.cn/jpush/server/push/server_overview/ 官方示例 https://github.com/jpush/jpush-api-java-client 推送通知123456789101112@Testpublic void token() throws Exception { String masterSecret = \"&lt;master-secret&gt;\"; String appKey = \"&lt;app-id&gt;\"; ClientConfig config = ClientConfig.getInstance(); JPushClient jpushClient = new JPushClient(masterSecret, appKey, null, config); PushPayload pushPayload = PushPayload.alertAll(\"Hello World!\"); PushResult pushResult = jpushClient.sendPush(pushPayload); log.info(\"resultOK: {}\", pushResult.isResultOK());} 源代码: PushClientTests.java","link":"/java/jiguang-push/"},{"title":"Json Web Token工具","text":"https://github.com/jwtk/jjwt 编码: 12345678910111213141516171819202122@Testpublic void compact() throws Exception { String secretKey = \"123456\"; Claims claims = Jwts.claims(); claims.setId(\"1\"); claims.setIssuer(\"sample\"); claims.setIssuedAt(new Date()); claims.setSubject(\"weitangli\"); claims.setAudience(\"guest\"); // 自定义属性 claims.put(\"uid\", \"1\"); String token = Jwts.builder() .setHeaderParam(Header.TYPE, Header.JWT_TYPE) .setClaims(claims) .signWith(SignatureAlgorithm.HS512, secretKey) .compact(); log.info(\"token: {}\", token);} 解码: 12345678910111213@Testpublic void parse() throws Exception { String secretKey = \"123456\"; String token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJqdGkiOiIxIiwiaXNzIjoic2FtcGxlIiwiaWF0IjoxNTc1MDIyMzIzLCJzdWIiOiJ3ZWl0YW5nbGkiLCJhdWQiOiJndWVzdCIsInVpZCI6IjEifQ.gZIsnPSXpM5NC1aPDlxZ-2nIkXvPgrmo8l351Dz99YaZlBL-SSOgxEP7MwMepFvq0DVkHPQSsbQIt4f8J7vCTw\"; Jws&lt;Claims&gt; jwt = Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(token); log.info(\"jwt: {}\", jwt); Claims claims = jwt.getBody(); log.info(\"claims: {}\", claims);} 源代码: JwtTests.java","link":"/java/jsonwebtoken/"},{"title":"Apache Maven打包插件Assembly","text":"Apache Maven项目提供的Maven插件Assembly能够将Maven应用的输出及其依赖库整合打包为一个压缩包, 以便于应用的分发使用. 项目结构: 12345678910111213141516171819[root@centos maven-assembly-sample]# tree --dirsfirst.├── src│ ├── main│ │ ├── java│ │ │ └── com│ │ │ └── sample│ │ │ └── Main.java│ │ └── resources│ └── test│ ├── java│ │ └── com│ │ └── sample│ └── resources├── assembly.xml├── pom.xml└── README.md11 directories, 4 files 在pom.xml添加以下内容: 12345678910111213141516171819202122&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.sample.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptors&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; assembly.xml的内容如下: 与依赖包一同打包 排除mysql:mysql-connector-java依赖 123456789101112131415161718192021&lt;assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"&gt; &lt;id&gt;jar-with-dependencies&lt;/id&gt; &lt;formats&gt; &lt;format&gt;jar&lt;/format&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;outputDirectory&gt;/&lt;/outputDirectory&gt; &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt; &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt; &lt;unpack&gt;true&lt;/unpack&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;excludes&gt; &lt;exclude&gt;mysql:mysql-connector-java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; assembly.xml的配置可以参考http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html 编码打包: 1mvn clean package 源代码:Main.javapom.xmlassembly.xml","link":"/java/maven-assembly/"},{"title":"网络请求工具okhttp","text":"https://github.com/square/okhttp 发送Get请求12345678910@Testpublic void get() throws Exception { String url = \"https://api.github.com/repos/square/okhttp/contributors\"; Request request = new Request.Builder().url(url).build(); Response response = new OkHttpClient().newCall(request).execute(); ResponseBody responseBody = response.body(); log.info(\"responseBody: {}\", responseBody.string());} 发送Post请求1234567891011121314@Testpublic void post() throws Exception { String url = \"https://api.github.com/repos/square/okhttp/contributors\"; MediaType contentType = MediaType.parse(\"application/json; charset=utf-8\"); String content = \"{}\"; RequestBody requestBody = RequestBody.create(contentType, content); Request request = new Request.Builder().url(url).post(requestBody).build(); Response response = new OkHttpClient().newCall(request).execute(); ResponseBody responseBody = response.body(); log.info(\"responseBody: {}\", responseBody.string());} 源代码: OkHttpTests.java","link":"/java/okhttp/"},{"title":"flux发生错误时的处理方式","text":"方式一: 发生错误时, 忽略此数据, 进入下一轮处理 1234567891011121314@Testpublic void onErrorContinue() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 忽略此数据 .onErrorContinue((err, num) -&gt; log.info(\"invalid num: {}\", num)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(5) .verifyComplete();} 方式二: 发生错误时, 忽略此数据, 然后使用[10, 20]继续接下来的操作 1234567891011121314@Testpublic void onErrorResume() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(-2, -1, 0, 1, 2) .map(n -&gt; 10 / n) // 使用[10, 20]继续接下来的操作 .onErrorResume(e -&gt; Flux.just(10, 20)); StepVerifier.create(flux) .expectNext(-5) .expectNext(-10) .expectNext(10) .expectNext(20) .verifyComplete();} 源代码: FluxErrorTests.java","link":"/java/reactor-flux-error/"},{"title":"让flux重复执行的案例","text":"案例一: 当数据为空时, 重复执行 最多重复执行3次, 每次间隔1秒 默认值为-1 123456789101112131415161718192021222324252627282930313233343536@Testpublic void repeatWhenEmpty() throws Exception { Flux&lt;Integer&gt; flux = Flux.defer( () -&gt; { log.info(\"return empty flux\"); return Flux.&lt;Integer&gt;empty(); }) .repeatWhen(repeatFactory -&gt; { Integer maxCount = 3; AtomicInteger counter = new AtomicInteger(0); return repeatFactory .takeWhile(size -&gt; { // 重复执行次数加1 Integer count = counter.incrementAndGet(); log.info(\"count={} size={}\", count, size); // 当数据为空时, 重复执行 if (size == 0) { // 最多重复执行3次 if (count &gt;= maxCount) { return false; } return true; } return false; }) // 每次间隔1秒 .delayElements(Duration.ofSeconds(1)); }) .switchIfEmpty(Flux.just(-1)); StepVerifier.create(flux) .expectNext(-1) .verifyComplete();} 源代码: FluxRepeatTests.java","link":"/java/reactor-flux-repeat/"},{"title":"flux的不同订阅方式","text":"方式一: 异步执行 12345678910@Testpublic void subscribeOn() throws Exception { Flux&lt;Integer&gt; flux = Flux.just(1) // 指定线程池 .subscribeOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNext(1) .verifyComplete();} 方式二: 并行执行 123456789101112@Testpublic void parallel() throws Exception { ParallelFlux&lt;Integer&gt; flux = Flux.range(1, 3) // 并行执行 .parallel() // 指定线程池 .runOn(Schedulers.elastic()); StepVerifier.create(flux) .expectNextCount(3) .verifyComplete();} 方式三: 延迟3秒后执行 12345678910111213@Testpublic void delaySubscription() throws Exception { StepVerifier.withVirtualTime(this::delayedFlux) .thenAwait(Duration.ofSeconds(3)) .expectNext(1) .verifyComplete();}private Flux&lt;Integer&gt; delayedFlux() { return Flux.just(1) // 延迟3秒 .delaySubscription(Duration.ofSeconds(3));} 源代码: FluxSubscribeTests.java","link":"/java/reactor-flux-subscribe/"},{"title":"mono缓存的使用","text":"方式一: 本地缓存 1分钟后过期 1234567891011121314151617@Testpublic void cache() throws Exception { String cacheKey = \"mykey\"; Cache&lt;String, Signal&lt;? extends Integer&gt;&gt; cache = CacheBuilder .newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .build(); Mono&lt;Integer&gt; mono = CacheMono .lookup(cache.asMap(), cacheKey) .onCacheMissResume(Mono.just(1)); StepVerifier.create(mono) .expectNext(1) .verifyComplete();} 源代码: MonoCacheTests.java","link":"/java/reactor-mono-cache/"},{"title":"reactor是如何推送数据的?","text":"方式一: UnicastProcessor 直接推送 线程安全 12345678910111213141516171819202122@Testpublic void unicastProcessor() throws Exception { UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create(); // 用于推送数据 FluxSink&lt;Integer&gt; sink = processor.sink(); // 消息发布者 Flux&lt;Integer&gt; publisher = processor.publish().autoConnect(); // 推送数据[1, 2, 3]后关闭 sink.next(1); sink.next(2); sink.next(3); sink.complete(); StepVerifier.create(publisher) .expectNext(1) .expectNext(2) .expectNext(3) .verifyComplete();} 源代码: ProcessorTests.java","link":"/java/reactor-processor/"},{"title":"RocketMQ Web管理工具","text":"https://github.com/apache/rocketmq-externals/tree/release-rocketmq-console-1.0.0/rocketmq-console","link":"/java/rocketmq-console/"},{"title":"快速安装RocketMQ","text":"https://rocketmq.apache.org 安装RocketMQ之前, 我们得先安装Java运行环境. Linux安装包下载地址: rocketmq-all-4.2.0-bin-release.zip 目录结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849├── benchmark├── bin│ ├── cachedog.sh│ ├── cleancache.sh│ ├── cleancache.v1.sh│ ├── mqadmin│ ├── mqadmin.cmd│ ├── mqadmin.xml│ ├── mqbroker│ ├── mqbroker.cmd│ ├── mqbroker.numanode0│ ├── mqbroker.numanode1│ ├── mqbroker.numanode2│ ├── mqbroker.numanode3│ ├── mqbroker.xml│ ├── mqfiltersrv│ ├── mqfiltersrv.cmd│ ├── mqfiltersrv.xml│ ├── mqnamesrv│ ├── mqnamesrv.cmd│ ├── mqnamesrv.xml│ ├── mqshutdown│ ├── mqshutdown.cmd│ ├── os.sh│ ├── play.cmd│ ├── play.sh│ ├── README.md│ ├── runbroker│ ├── runbroker.cmd│ ├── runbroker.sh│ ├── runserver.cmd│ ├── runserver.sh│ ├── setcache.sh│ ├── startfsrv.sh│ ├── tools.cmd│ └── tools.sh├── conf│ ├── 2m-2s-async│ ├── 2m-2s-sync│ ├── 2m-noslave│ ├── broker.conf│ ├── logback_broker.xml│ ├── logback_filtersrv.xml│ ├── logback_namesrv.xml│ └── logback_tools.xml├── lib├── LICENSE├── NOTICE└── README.md bin目录下提供了启动脚本, 包括了cmd和shell版本. 配置修改修改conf/broker.conf, 内容如下: 1234567891011# brokerClusterName = DefaultCluster# brokerName = broker-a# brokerId = 0# deleteWhen = 04# fileReservedTime = 48# brokerRole = ASYNC_MASTER# flushDiskType = ASYNC_FLUSH# 如果不是部署在本地, 得配置具体的IP地址brokerIP1 = localhostbrokerIP2 = localhost 启动NameServer12345nohup bin/mqnamesrv &amp;tail -f ~/logs/rocketmqlogs/namesrv.log# 关闭# bin/mqshutdown namesrv 启动Broker12345nohup bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;tail -f ~/logs/rocketmqlogs/broker.log# 关闭# bin/mqshutdown broker 测试1234567export NAMESRV_ADDR=localhost:9876# 生产者bin/tools.sh org.apache.rocketmq.example.quickstart.Producer# 消费者bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer","link":"/java/rocketmq-install/"},{"title":"使用RocketMQ收发信息","text":"https://rocketmq.apache.org/docs/simple-example 生产者: 12345678910111213141516171819202122@Testpublic void produceMessage() throws Exception { // 初始化 DefaultMQProducer producer = new DefaultMQProducer(); producer.setNamesrvAddr(namesrvAddr); producer.setProducerGroup(producerGroup); // 启动 producer.start(); // 发送消息 String topic = \"default-mq\"; String tags = \"test\"; String content = \"hello world!\"; Message message = new Message(topic, tags, content.getBytes(Charset.forName(\"UTF-8\"))); SendResult sendResult = producer.send(message); log.info(\"send message: topic={} tags={} content={} status={}\", topic, tags, content, sendResult.getSendStatus().name()); // 关闭 producer.shutdown();} 消费者: 12345678910111213141516171819202122232425262728293031@Testpublic void consumeMessage() throws Exception { // 初始化 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(); consumer.setNamesrvAddr(namesrvAddr); consumer.setConsumerGroup(consumerGroup); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); // 订阅消息 String topic = \"default-mq\"; String subExpression = \"*\"; consumer.subscribe(topic, subExpression); // 监听消息 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context) { messages.forEach(message -&gt; { log.info(\"receive message: topic={} tags={} message={}\", message.getTopic(), message.getTags(), new String(message.getBody())); }); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); // 启动 consumer.start(); while (true) { Thread.yield(); }} 源代码: DefaultMQTests.java","link":"/java/rocketmq-simple/"},{"title":"JVM应用平台vertx","text":"https://vertx.io Vert.x是一个轻量级的高性能JVM应用平台.","link":"/java/vertx/"},{"title":"排序算法","text":"冒泡排序12345678910111213141516171819202122232425262728293031@Testpublic void bubble() { int[] numbers = {3, 2, 1, 5, 4}; log.info(\"numbers: {}\", numbers); sort(numbers); log.info(\"after sort: {}\", numbers);}/** * 冒泡法排序 O(n2) * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 针对所有的元素重复以上的步骤，除了最后一个。 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * * @param numbers 需要排序的整型数组 */public static void sort(int[] numbers) { int temp; // 记录临时中间值 int size = numbers.length; // 数组大小 for (int i = 0; i &lt; size - 1; i++) { for (int j = i + 1; j &lt; size; j++) { if (numbers[i] &lt; numbers[j]) { // 交换两数的位置 temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp; } } }} 插入排序1234567891011121314151617181920212223242526272829@Testpublic void insertion() { int[] numbers = {3, 2, 1, 5, 4}; log.info(\"numbers: {}\", numbers); sort(numbers); log.info(\"after sort: {}\", numbers);}/** * 插入排序 O(n2) * 从第一个元素开始，该元素可以认为已经被排序 * 取出下一个元素，在已经排序的元素序列中从后向前扫描 * 如果该元素（已排序）大于新元素，将该元素移到下一位置 * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 * 将新元素插入到该位置中 * 重复步骤2 * * @param numbers */public static void sort(int[] numbers) { int size = numbers.length, temp, j; for (int i = 1; i &lt; size; i++) { temp = numbers[i]; for (j = i; j &gt; 0 &amp;&amp; temp &lt; numbers[j - 1]; j--) numbers[j] = numbers[j - 1]; numbers[j] = temp; }} 选择排序123456789101112131415161718192021222324252627282930@Testpublic void selection() { int[] numbers = {3, 2, 1, 5, 4}; log.info(\"numbers: {}\", numbers); sort(numbers); log.info(\"after sort: {}\", numbers);}/** * 选择排序 O(n2) * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * 以此类推，直到所有元素均排序完毕。 * * @param numbers */public static void sort(int[] numbers) { int size = numbers.length, temp; for (int i = 0; i &lt; size; i++) { int k = i; for (int j = size - 1; j &gt; i; j--) { if (numbers[j] &lt; numbers[k]) k = j; } temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; }} 源代码:BubbleSortTests.javaInsertionSortTests.javaSelectionSortTests.java","link":"/java/sorting-algorithms/"},{"title":"爬虫框架webmagic","text":"https://webmagic.io WebMagic是一个简单灵活的Java爬虫框架。基于WebMagic，你可以快速开发出一个高效、易维护的爬虫。 特性： 简单的API，可快速上手 模块化的结构，可轻松扩展 提供多线程和分布式支持 一个爬取Github仓库的示例： 1234567@Testpublic void run() throws Exception { Spider.create(new GithubRepoPageProcessor()) .addUrl(\"https://github.com/code4craft\") .thread(5) .run();} 12345678910111213141516171819202122public class GithubRepoPageProcessor implements PageProcessor { private Site site = Site.me().setRetryTimes(3).setSleepTime(1000).setTimeOut(10000); @Override public void process(Page page) { page.addTargetRequests(page.getHtml().links().regex(\"(https://github\\\\.com/[\\\\w\\\\-]+/[\\\\w\\\\-]+)\").all()); page.addTargetRequests(page.getHtml().links().regex(\"(https://github\\\\.com/[\\\\w\\\\-])\").all()); page.putField(\"author\", page.getUrl().regex(\"https://github\\\\.com/(\\\\w+)/.*\").toString()); page.putField(\"name\", page.getHtml().xpath(\"//h1[@class='entry-title public']/strong/a/text()\").toString()); if (page.getResultItems().get(\"name\") == null) { // skip this page page.setSkip(true); } page.putField(\"readme\", page.getHtml().xpath(\"//div[@id='readme']/tidyText()\")); } @Override public Site getSite() { return site; }} 源代码:SpiderTests.javaGithubRepoPageProcessor.java","link":"/java/webmagic/"},{"title":"微信个人号API","text":"https://biezhi.github.io/wechat-api/ wechat-api一个基于微信Web协议的Java版本封装，提供了发送消息、接受消息、群操作等功能。 一个例子: 1234@Testpublic void start() { new HelloBot(Config.me().autoLogin(true).showTerminal(true)).start();} 机器人: 12345678910111213141516public class HelloBot extends WeChatBot { private Logger log = LoggerFactory.getLogger(this.getClass()); public HelloBot(Config config) { super(config); } @Bind(msgType = MsgType.TEXT) public void handleText(WeChatMessage message) { if (StringUtils.isNotEmpty(message.getName())) { log.info(\"接收到 [{}] 的消息: {}\", message.getName(), message.getText()); this.sendMsg(message.getFromUserName(), \"自动回复: \" + message.getText()); } }} 源代码:HelloBotTests.javaHelloBot.java","link":"/java/wechat-api/"}],"tags":[{"name":"activemq","slug":"activemq","link":"/tags/activemq/"},{"name":"alibaba","slug":"alibaba","link":"/tags/alibaba/"},{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"apache-commons","slug":"apache-commons","link":"/tags/apache-commons/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"jackson","slug":"jackson","link":"/tags/jackson/"},{"name":"easemob","slug":"easemob","link":"/tags/easemob/"},{"name":"jooq","slug":"jooq","link":"/tags/jooq/"},{"name":"jiguang","slug":"jiguang","link":"/tags/jiguang/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"okhttp","slug":"okhttp","link":"/tags/okhttp/"},{"name":"reactor","slug":"reactor","link":"/tags/reactor/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"},{"name":"vertx","slug":"vertx","link":"/tags/vertx/"},{"name":"sorting-algorithms","slug":"sorting-algorithms","link":"/tags/sorting-algorithms/"},{"name":"webmagic","slug":"webmagic","link":"/tags/webmagic/"},{"name":"wechat-api","slug":"wechat-api","link":"/tags/wechat-api/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"windows10","slug":"windows10","link":"/categories/windows10/"}]}